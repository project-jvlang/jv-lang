# フェーズ2: 型システム - 実装チェックリスト

## 概要
- **目的**: 堅牢な型推論システムとnull安全解析の実装
- **主要成果物**: 型推論エンジン、null安全解析、パターンマッチング、ジェネリック処理

---

## 5. 型推論エンジン

### 5.1 Hindley-Milner型推論基盤
- [x] 型変数（Type Variable）システムの実装
- [x] 統一化（Unification）アルゴリズムの実装
- [x] 型環境（Type Environment）管理システム
- [x] 型制約生成・解決メカニズム
- [x] 型エラーメッセージ生成システム

### 5.2 ローカル型推論
- [x] 変数宣言時の型推論（`val x = 42` → `Int`）
- [x] 式の型推論（算術演算、比較演算）
- [x] 関数呼び出し時の引数型推論
- [x] 戻り値型の推論
- [x] 型アノテーション省略サポート

### 5.3 型推論の高度機能
- [x] 多相型（Polymorphic Types）のサポート
- [x] 型パラメータの推論
- [x] 制約付き型推論（where句相当）
- [x] 相互再帰関数の型推論
- [x] クロージャ・ラムダ式の型推論

### 5.4 エラーハンドリング・診断
- [x] 型不一致エラーの詳細報告
- [x] 型推論失敗時の提案システム
- [x] 循環型依存の検出・報告
- [x] パフォーマンス最適化（型キャッシュ）

---

## 6. null安全解析

### 6.1 null安全型システム設計
- [x] nullable型（`String?`）とnon-null型（`String`）の区別
- [x] null安全演算子（`?.`, `?:`, `!!`）の型解析
- [x] null値の追跡・伝播解析
- [x] 条件分岐でのnull型細分化（Type Narrowing）

### 6.2 フロー型解析（Flow Analysis）
- [x] 制御フロー解析エンジンの実装
- [x] 分岐条件でのnull検査認識
- [x] try-catch文でのnull型状態管理
- [x] 関数終了パスでのnull安全性検証

### 6.3 null安全検証
- [x] null参照可能性の静的解析
- [x] 安全でないnull参照の警告・エラー
- [x] null安全演算子の必要性判定
- [x] 初期化検証（lateinit変数相当）

### 6.4 Java相互運用でのnull安全
- [x] Java APIのnull注釈認識
- [x] 外部ライブラリのnull安全性推論
- [x] JNI/FFMでのnull安全性検証
- [x] プラットフォーム型（Platform Types）の処理

### 6.5 Javaアノテーション処理（パススルー方式）
- [x] Javaアノテーションのパススルー機構
  - [x] Java標準アノテーション（`@Override`, `@Deprecated`等）のパススルー
  - [x] サードパーティアノテーション（JSR-305, Spring, JetBrains等）のパススルー
  - [x] カスタムアノテーションの透過的サポート
  - [x] アノテーション引数の構文検証（型チェックなし）
- [x] アノテーション位置検証
  - [x] クラス・メソッド・フィールド・パラメータ位置の妥当性チェック
  - [x] Java言語仕様に基づく配置可能位置の検証
  - [x] 不正な位置への配置時のエラー報告
- [x] jv独自アノテーションとの衝突検出
  - [x] jv予約アノテーション（`@Sample`, `@Unit`等）との衝突警告
  - [x] 同一要素への重複アノテーション検出
  - [x] 互換性のないアノテーション組み合わせの警告
- [x] null安全性アノテーションの特殊処理
  - [x] `@Nullable`, `@NonNull`系アノテーションの認識
  - [x] 型推論システムへのnull安全性情報の伝達
  - [x] 複数null安全ライブラリ間の優先順位設定

#### ✅未完了タスク（要着手）
- null safety 統合テスト対応（既知未実装項目）
  1. `when` パターンにおける `is` 構文解析を拡張し、null safety のスマートキャストを成立させる
  2. Nullable 型記法など高度な `TypeAnnotation` 解析を実装し、推論・パターン解析へ連携する
  3. 上記対応後、null safety 統合テストの失敗ケースを再検証し、回帰防止テストを整備する

---

## 7. パターンマッチングサポート

### 7.1 `when`式の型解析
- [x] `when`式の網羅性検査（Exhaustiveness Check）
- [x] 分岐条件の型ガード認識
- [x] パターンマッチングでの型細分化
- [x] `else`分岐の必要性判定

### 7.2 Java 25 switch/pattern変換
- [x] `when`式からJava switch式への変換
- [x] パターンマッチングのJavaバイトコード生成
- [x] sealed classとの連携
- [x] 型安全なパターン分解（Destructuring）

### 7.3 高度なパターンマッチング
- [x] データクラスの分解パターン
- [x] ネストしたパターンマッチング
- [x] ガード条件（when文での追加条件）
- [x] 変数バインディングパターン

### 7.4 エラー処理・最適化
- [x] パターンマッチングの型エラー検出
- [x] 未使用パターンの警告
- [x] 到達不可能パターンの検出
- [x] パフォーマンス最適化（分岐順序最適化）

### 7.5 仕様更新対応（拡張パターンマッチ）
- [x] `in`範囲パターン（`0..10`排他・`0..=10`包括）の型解析とコード生成
  - [x] 範囲境界の型チェック（比較可能型の検証）
  - [x] Java switch式への最適変換（範囲チェックのif連鎖）
  - [x] 包括・排他範囲の正確な境界処理
- [x] ガード付き`is`パターン（`is Int && 条件`）の型ナローイング規則更新
  - [x] 型ガード後のスマートキャスト実装
  - [x] 複合条件での型情報伝播
  - [x] ガード条件の型安全性検証
- [x] 引数なし`when`式（条件ブロックのみ）の網羅性検査と型推論
  - [x] Boolean式としての網羅性解析
  - [x] else分岐の必要性判定
  - [x] 戻り値型の統一検証
- [x] `if`式検知時の`when`式への変換アドバイス
  - [x] `if`構文検出時のコンパイルエラー生成
  - [x] 等価な`when`式への変換候補提示
  - [x] Quick Fixによる自動変換機能（IDE連携）
  - [x] 修正候補メッセージのテンプレート実装
- [x] パターンマッチ仕様ドキュメントの改訂（範囲・ガード例の追記）

### 7.6 ドキュメント / テレメトリ最終同期（2025-09-29）
- [x] `design.md`, `tasks.md`, `docs/pattern-matching*.md` を最終版へ更新
- [x] `jv check --telemetry` で `pattern_cache_*`, `pattern_bridge_ms`, `when_strategy` が表示されることを確認
- [x] `.project-todolist/phase2-checklist.md` と Definition of Done の完了フラグを同期

### 7.7 ラベル付きブロック/ラムダとbreak/continue/return（`#`記号統一）
- [ ] ラベル構文のパーシング
  - [ ] `#識別子` 形式の認識（ハッシュ接頭辞）
  - [ ] ブロックラベル: `#outer for { }`, `#validation { }`
  - [ ] ラムダラベル: `forEach #outer { }`, `run #compute { }`
  - [ ] ラベルスコープの管理（ネストしたラベルの解決）
  - [ ] AST構築（LabeledBlockNode, LabeledLambdaNode）
- [ ] ラベル付きbreak構文
  - [ ] `break #label` 形式のパーシング
  - [ ] ラベルスコープの検証（宣言されたラベルへのみジャンプ可能）
  - [ ] 任意のブロックからの脱出サポート（ループ、通常ブロック、when式等）
  - [ ] Java `break label;` への変換（`#`を除去）
- [ ] ラベル付きcontinue構文
  - [ ] `continue #label` 形式のパーシング
  - [ ] ループラベルへのcontinueのみ許可（ループ以外はエラー）
  - [ ] ラベルスコープの検証
  - [ ] Java `continue label;` への変換（`#`を除去）
- [ ] ラベル付きreturn構文（ラムダ専用）
  - [ ] `return #label` 形式のパーシング（戻り値なし）
  - [ ] `return #label 式` 形式のパーシング（戻り値あり）
  - [ ] ラムダラベルへのreturnのみ許可（ブロックラベルはエラー）
  - [ ] ネストしたラムダからの早期脱出サポート
  - [ ] Java変換戦略
    - [ ] Unitラムダ: `return;` に変換
    - [ ] 値を返すラムダ: `return 式;` に変換
    - [ ] ラムダ最後の式を自動的に`return`文に変換
- [ ] ネストしたラベルの解決
  - [ ] 複数レベルのラベルスコープ管理（ブロック＋ラムダ）
  - [ ] 同名ラベルのシャドーイング処理
  - [ ] 最も近い一致するラベルの解決
  - [ ] 曖昧なラベル参照のエラー検出
- [ ] エラー処理
  - [ ] 未定義ラベルへのbreak/continue/returnエラー
  - [ ] ループ以外へのcontinueエラー
  - [ ] ブロックラベルへのreturnエラー
  - [ ] ラムダラベルへのbreak/continueエラー
  - [ ] ラベル名の重複エラー（同一スコープ内）
  - [ ] ネストレベル検証エラー

### 7.8 初期化ブロック構文（`{{ }}`）
- [ ] 二重ブレース構文のパーシング
  - [ ] `変数: 型 = {{ 初期化処理 }}` 形式の認識
  - [ ] ラムダ（`{ }`）との字句レベル区別
  - [ ] ブロック内文の解析
  - [ ] AST構築（DoublebraceInitNode）
- [ ] 型推論エンジン統合
  - [ ] インターフェース型からデフォルト実装の推論
    - [ ] `List<T>` → `ArrayList<T>`
    - [ ] `Set<T>` → `HashSet<T>`
    - [ ] `Map<K,V>` → `HashMap<K,V>`
    - [ ] `Queue<T>` → `LinkedList<T>`
  - [ ] ジェネリック型パラメータの推論
    - [ ] 単一型パラメータ（`list = {{ add(1) }}` → `ArrayList<Integer>`）
    - [ ] 複数型パラメータ（`map = {{ put("k", 1) }}` → `HashMap<String, Integer>`）
    - [ ] ネストしたジェネリック型（`{{ add([1, 2]) }}` → `ArrayList<List<Integer>>`）
    - [ ] 混在型の共通上位型への昇格（`{{ add(1); add(2.5) }}` → `ArrayList<Number>`）
  - [ ] 抽象クラスからの具象クラス推論
  - [ ] data class/recordのコンストラクタ推論
  - [ ] 空の初期化ブロックのデフォルト型処理
    - [ ] 型注釈なし: `val x = {{}}` → `Object`型
    - [ ] 型注釈あり: `val x: List<T> = {{}}` → 指定された型
  - [ ] 推論不可能な型のエラー報告
- [ ] デフォルト実装マッピング
  - [ ] `jv.toml` からの設定読み込み
  - [ ] `[compiler.type_inference.default_implementations]` セクション処理
  - [ ] カスタムマッピングのサポート
- [ ] レシーバーコンテキストの実装
  - [ ] ブロック内での暗黙的レシーバー参照
  - [ ] フィールドアクセスの自動解決（`name` → `this.name`）
  - [ ] メソッド呼び出しの自動解決（`add(1)` → `this.add(1)`）
  - [ ] `this`による明示的参照のサポート
- [ ] 明示的コンストラクタ呼び出し（オプション）
  - [ ] `変数: 型 = Constructor() {{ ... }}` 形式のパーシング
  - [ ] コンストラクタ引数の解析
  - [ ] 型推論のオーバーライド
- [ ] 既存オブジェクトへの適用
  - [ ] `変数: 型 = existingObj {{ ... }}` 形式のパーシング
  - [ ] 既存オブジェクトのコピー生成（data class/record）
  - [ ] Mutableオブジェクトの直接変更
  - [ ] Immutable/Mutableの判定
- [ ] Java変換ルール
  - [ ] 型推論された実装クラスのインスタンス化
  - [ ] セッター呼び出しへの変換
  - [ ] Builderパターン検出とメソッドチェーン最適化
  - [ ] 一時変数の生成と管理
- [ ] エラーハンドリング
  - [ ] デフォルト実装が推論できない型のエラー
  - [ ] 抽象クラス/インターフェースの曖昧性エラー
  - [ ] 存在しないフィールド/メソッドアクセスエラー
  - [ ] 型不一致エラー
  - [ ] Immutableオブジェクトへの変更エラー


### 7.9 アンダースコア構文（暗黙引数とワイルドカード）

#### 7.9.1 字句解析
- [ ] アンダースコアトークンの認識
  - [ ] `_` 単独トークンの認識
  - [ ] `_1`, `_2`, `_3`, ... 暗黙引数トークンの認識
  - [ ] `_0` の禁止検出（エラー報告）
  - [ ] 識別子としての `_` との区別（文脈依存）
  - [ ] AST構築（UnderscoreToken, ImplicitParamToken）

#### 7.9.2 暗黙引数（`_1`, `_2`, `_3`, ...）
- [ ] ラムダ式内での暗黙引数パーシング
  - [ ] `{ _1 * 2 }` 形式の認識
  - [ ] `{ _1 + _2 }` 複数引数の認識
  - [ ] `{ _1 * _1 }` 同一引数の複数回使用
  - [ ] 使用された最大番号からの引数数推論
  - [ ] AST構築（ImplicitParamNode）
- [ ] スコープ管理
  - [ ] ラムダ式スコープ内でのみ使用可能
  - [ ] 通常の関数内での使用禁止検出
  - [ ] ネストしたラムダでの独立したスコープ
- [ ] 明示的引数との混在禁止
  - [ ] `{ x -> _1 }` 形式の検出とエラー報告
  - [ ] `{ _ -> _1 }` ワイルドカードとの混在検出
  - [ ] 明示的引数宣言の有無チェック
- [ ] 引数数の推論と検証
  - [ ] 最大番号からの引数数決定（`_3` → 3引数）
  - [ ] 未使用引数の許可（`_1`, `_3` のみ使用 → `_2` は未使用だが存在）
  - [ ] 関数シグネチャとの整合性検証
- [ ] Java変換
  - [ ] 暗黙引数を明示的パラメータに変換（`_1` → `__arg1`）
  - [ ] ラムダ引数リストの生成
  - [ ] 引数の型推論との連携

#### 7.9.3 ワイルドカードパターン（`_` 単独）
- [ ] 分割代入でのワイルドカード
  - [ ] `val (x _ z) = triple` 形式のパーシング
  - [ ] タプル分解での要素無視
  - [ ] 複数ワイルドカードのサポート（`val (a _ _ d) = tuple4`）
  - [ ] AST構築（WildcardPatternNode）
  - [ ] Java変換（無視される値の取得スキップ）
- [ ] パターンマッチングでのワイルドカード
  - [ ] when式での `Err(_)` パターン
  - [ ] データクラス分解での部分無視（`Point(0 0 _)`）
  - [ ] 複数フィールドでのワイルドカード（`Response(200 body _)`）
  - [ ] ワイルドカードのバインディング禁止
  - [ ] Java変換（`__unused` 変数への変換）
- [ ] ラムダ引数でのワイルドカード
  - [ ] `{ _ -> expr }` 引数を使わないラムダ
  - [ ] `{ key _ -> expr }` 一部引数の無視
  - [ ] `{ _ _ -> expr }` 全引数の無視
  - [ ] 副作用のみの実行サポート
  - [ ] Java変換（`__unused` パラメータ）
- [ ] 変数宣言でのワイルドカード
  - [ ] `val _ = func()` 戻り値の明示的無視
  - [ ] 副作用のみ実行の意図表明
  - [ ] 未使用変数警告の抑制

#### 7.9.4 使い分けと文脈判定
- [ ] 判定ロジックの実装
  - [ ] `_` の後に数字が続くか判定
  - [ ] 文脈による意味の決定（分割代入/パターンマッチ/ラムダ/変数宣言）
  - [ ] スコープ解析との連携
- [ ] 構文判定表の実装
  - [ ] 暗黙引数: `_1`, `_2`, ... → ラムダ内の式
  - [ ] ワイルドカード: `_` → パターン位置
  - [ ] 文脈による自動判別

#### 7.9.5 エラーハンドリング
- [ ] ワイルドカードへのアクセスエラー
  - [ ] `val (x _) = pair; println(_)` の検出
  - [ ] "wildcard `_` cannot be referenced as a value" エラー
  - [ ] 修正提案の生成
- [ ] 暗黙引数とワイルドカードの混在エラー
  - [ ] `{ _ value -> _1 }` の検出
  - [ ] "cannot use implicit parameters when explicit parameters are declared" エラー
  - [ ] どちらか一方を使用するよう提案
- [ ] `_0` 使用エラー
  - [ ] `{ _0 * 2 }` の検出
  - [ ] "implicit parameter numbering starts at `_1`, not `_0`" エラー
  - [ ] `_1` への修正提案
- [ ] スコープエラー
  - [ ] 通常の関数内での `_1` 使用検出
  - [ ] "implicit parameters can only be used in lambda expressions" エラー
- [ ] エラーメッセージの国際化
  - [ ] エラーメッセージキーの定義
  - [ ] 日本語・英語のメッセージ用意

#### 7.9.6 型推論との統合
- [ ] 暗黙引数の型推論
  - [ ] ラムダの期待される型から引数型を推論
  - [ ] `numbers.map { _1 * 2 }` → `_1: Int`
  - [ ] 複数引数の型推論（`_1: K`, `_2: V` など）
- [ ] ワイルドカードの型検証
  - [ ] パターンマッチでの型整合性チェック
  - [ ] 分割代入での要素数検証
  - [ ] エラー時の型情報提供

#### 7.9.7 Java変換規則
- [ ] 暗黙引数の変換
  - [ ] `_1` → `__arg1`, `_2` → `__arg2` の命名規則
  - [ ] ラムダパラメータリストの生成
  - [ ] 型アノテーションの付与
- [ ] ワイルドカードの変換
  - [ ] 分割代入: 取得コードの省略
  - [ ] パターンマッチ: `__unused`, `__unused1`, `__unused2` への変換
  - [ ] ラムダ引数: `__unused` パラメータ
  - [ ] 変数宣言: 変数宣言の省略または `__unused` 変数
- [ ] 変換コードの最適化
  - [ ] 使用されない一時変数の削減
  - [ ] 不要なコード生成の回避

#### 7.9.8 LSP補完サポート
- [ ] 暗黙引数の補完
  - [ ] ラムダ式内での `_1`, `_2`, ... の提案
  - [ ] 推論された引数数に基づく補完候補
  - [ ] 型情報のツールチップ表示
- [ ] ワイルドカードの補完
  - [ ] パターン位置での `_` の提案
  - [ ] 分割代入での利用例の表示
  - [ ] 使い分けのヒント提供

#### 7.9.9 テスト
- [ ] 暗黙引数のテスト
  - [ ] 単一引数ラムダ（`{ _1 * 2 }`）
  - [ ] 複数引数ラムダ（`{ _1 + _2 }`）
  - [ ] 引数の複数回使用（`{ _1 * _1 }`）
  - [ ] 飛び番号（`{ _1 + _3 }`）
  - [ ] ネストしたラムダでのスコープ
  - [ ] エラーケース（混在、`_0`、スコープ外）
- [ ] ワイルドカードのテスト
  - [ ] 分割代入での無視（`val (x _ z) = triple`）
  - [ ] パターンマッチでの無視（`Err(_)`）
  - [ ] ラムダ引数の無視（`{ _ -> expr }`）
  - [ ] 変数宣言での無視（`val _ = func()`）
  - [ ] エラーケース（アクセス禁止、混在）
- [ ] 統合テスト
  - [ ] 実際のコード例での動作確認
  - [ ] Java変換結果の検証
  - [ ] 型推論との連携確認
  - [ ] エラーメッセージの品質確認

---

## 8. ジェネリック型処理

### 8.1 型パラメータ推論
- [x] 関数呼び出し時の型引数推論
- [x] ジェネリックコンストラクタの型推論
- [x] 型パラメータの境界（Bounds）処理
- [x] 変位指定（Variance）の解析

### 8.2 型制約解決
- [x] where句相当の制約システム
- [x] 型クラス（Type Class）相当の機能
- [x] 複数型制約の同時解決
- [x] 制約違反時のエラーメッセージ
- [ ] キャッシュヒット率を SolverTelemetry の cache_hit_rate へ還元するパイプライン整備
- [ ] 大規模ケース向けの追加ベンチ（能力束縛を含むシナリオなど）の検討

### 8.3 Java相互運用性
- [x] Javaジェネリクスとの型マッピング
- [x] Raw型の処理
- [x] 型消去（Type Erasure）対応
- [x] ワイルドカード型（`? extends`, `? super`）対応
- [ ] Raw型の深刻度分類と対応策プラン策定（TODO）
- [ ] 既存型トークン機構の適用範囲棚卸しと不足ケースの洗い出し（TODO）

### 8.4 高度なジェネリック機能
- [x] パーサで汎用型宣言（`<T>`）を解析しASTへ組み込む
  - [ ] `data SequenceCore<T>` などの型パラメータ宣言をサポート
  - [x] ジェネリック関数 `fun <T, R>` の構文に対応
- [ ] 高階型（Higher-Kinded Types）の基本サポート
- [ ] 型レベル計算の基本機能
- [ ] 依存型の簡単な形式
- [ ] 型安全な反射API設計

---

## 9. 正規表現サポート（作業指示書 §9）

**設計原則**: Javaの`java.util.regex.Pattern`へのシンタックスシュガー。新しいキーワードを導入せず、既存の`is`演算子と文字列リテラルを活用。

### 9.1 正規表現リテラル
- [x] スラッシュリテラル（`/.../`）のパーシング
  - [x] 正規表現パターンの字句解析
  - [x] エスケープシーケンスの処理
  - [x] AST構築（RegexLiteralNode）
  - [x] Java `Pattern.compile()` への変換
- [x] コンパイル時正規表現バリデーション
  - [x] 正規表現文法チェック
  - [x] 不正パターンのエラー報告
  - [x] 修正候補の提示

### 9.2 生文字列リテラル
- [x] シングルクォート文字列（`'...'`）のパーシング
  - [x] エスケープ処理なしの文字列解釈
  - [x] 文字列補間なしの処理
  - [x] 1文字の場合は`Char`型、2文字以上は`String`型への自動判別
  - [x] AST構築（RawStringLiteralNode）

### 9.3 `is`演算子の正規表現拡張
- [-] `is`演算子での正規表現マッチング
  - [x] `text is /pattern/` 構文のパーシング
  - [ ] `Pattern.matcher().matches()` への変換
  - [ ] パターンマッチング統合（`when`式での使用）
  - [ ] 型推論との統合

### 9.4 簡潔な正規表現構文
- [ ] Perl/sed風構文のパーシング
  - [ ] `[mode]/string/pattern/[arg]/[flags]` 形式の認識
  - [ ] モード省略形（`a`, `f`, `i`, `m`, `s`）のサポート
  - [ ] デフォルトモード推論（置換構文は`a`, マッチ構文は`m`）
- [ ] 置換構文の実装
  - [ ] `a`（all）モード: `replaceAll()` への変換
  - [ ] `f`（first）モード: `replaceFirst()` への変換
  - [ ] 後方参照（`$1`, `$2`等）のサポート
  - [ ] 文字列補間（`${it.group(1)}`）のサポート
- [ ] マッチ構文の実装
  - [ ] `m`（match）モード: `matches()` への変換（真偽値返却）
  - [ ] `s`（search）モード: `find()` への変換（真偽値返却）
- [ ] イテレータ構文の実装
  - [ ] `i`（iterate）モード: `Matcher`イテレータへの変換
  - [ ] マッチ結果コレクションの生成
  - [ ] ラムダ式による高度な置換処理
- [ ] フラグ指定の実装
  - [ ] `i` (CASE_INSENSITIVE) フラグ
  - [ ] `m` (MULTILINE) フラグ
  - [ ] `s` (DOTALL) フラグ
  - [ ] `u` (UNICODE_CASE) フラグ
  - [ ] `d` (UNIX_LINES) フラグ
  - [ ] `x` (COMMENTS) フラグ
  - [ ] `l` (LITERAL) フラグ
  - [ ] `c` (CANON_EQ) フラグ
  - [ ] 複数フラグの組み合わせ（`im`, `ius`等）
  - [ ] `Pattern.compile(pattern, flags)` への変換

### 9.5 型システムとの統合
- [ ] `Pattern`型の認識と型推論
  - [ ] 正規表現リテラルの型を`java.util.regex.Pattern`として推論
  - [ ] `List<Pattern>`, `Map<String, Pattern>`等のジェネリック対応
- [ ] 型安全性の保証
  - [ ] 定数正規表現のコンパイル時最適化
  - [ ] `static final Pattern`への変換と再利用
  - [ ] 動的パターンの実行時検証

### 9.6 Java相互運用性
- [ ] Java標準APIとの統合
  - [ ] `Pattern`/`Matcher` APIの直接使用サポート
  - [ ] `String.split(/pattern/)` のサポート
  - [ ] `String.replaceAll(/pattern/, replacement)` のサポート

### 9.7 エラーハンドリング
- [ ] パターン構文エラーの検出
  - [ ] 不正なスラッシュリテラルの検出
  - [ ] モード指定エラーの検出
  - [ ] フラグ指定エラーの検出
- [ ] エラーメッセージの改善
  - [ ] 具体的なエラー位置の特定
  - [ ] 修正候補の提示
  - [ ] Java正規表現ドキュメントへのリンク

---

## 10. アノテーション・単位系構文処理

**スコープ**: 構文パーシングとAST構築まで（意味解析・型システム統合はPhase 3）

### 10.1 Javaアノテーション処理
- [x] Javaアノテーション構文のパーシング
  - [x] `@識別子` 形式の認識（**スペースなし**）
  - [x] アノテーション引数のパーシング（単一値、名前付き、配列、ネスト）
  - [x] AST構築（AnnotationNode）
- [x] jv独自アノテーションの識別
  - [x] `@Sample` の認識（コンパイル時処理用）
  - [x] `@Mock`, `@PactSample` 等の認識
  - [x] jv専用アノテーションのフラグ付け
- [x] Javaアノテーションパススルー処理
  - [x] 位置・構文検証済みアノテーションのそのままの出力
  - [x] アノテーション引数の保持
  - [x] Retention/Targetメタデータの保持
- [ ] コンパイル時アノテーション処理（APT）統合
  - [ ] Java APTとの連携インターフェース
  - [ ] カスタムアノテーションプロセッサへの委譲
- [-] アノテーション検証・エラーレポート
  - [x] 位置検証エラーの詳細報告
  - [x] 衝突検出時の具体的な修正提案
  - [ ] jv/Java境界でのアノテーション使用ガイド

### 10.2 単位系構文処理
- [ ] 単位型定義構文のパーシング（基礎構文のみ）
  - [ ] `@ 単位系(基底型) 識別子 { }` 形式の認識（**`@` 直後にスペース必須** - Javaアノテーションと区別）
  - [ ] Javaアノテーションとの字句レベル区別（`@` 直後のスペース有無で判定）
  - [ ] デフォルト単位マーカー（`!`サフィックス）のパーシング
  - [ ] 単位依存関係構文（`:=`, `->`）のパーシング
  - [ ] 変換関数ブロック（`@Conversion`, `@ReverseConversion`）のパーシング
  - [ ] AST構築（UnitTypeDefNode）
  - [ ] **注**: 意味解析・型システム統合はPhase 3で実装
- [ ] 単位リテラル・型パラメータ構文のパーシング
  - [ ] 値リテラル（`1000@USD`, `1000@ USD`, `1000 @USD`, `1000 @ USD`）のパーシング（**`@` 直後スペース許容**）
  - [ ] 型パラメータ（`Int@m`, `Int m`）のパーシング
  - [ ] `@` 省略形式のサポート（`100m` 等）
  - [ ] 単位変換構文（`as @USD`, `as @ USD`）のパーシング（**`@` 直後スペース許容**）
  - [ ] 演算子含む単位（`25@[°C]`）のパーシング
  - [ ] AST構築（UnitLiteralNode, UnitTypeParamNode）
  - [ ] **注**: 型検証・変換処理はPhase 3で実装

---

## 11. ロギングフレームワーク統合（作業指示書 §8）

### 11.1 基本ロギング構文
- [ ] ログブロック構文のパーシング
  - [ ] `LOG { ... }` 無条件ログブロック
  - [ ] `TRACE { ... }`, `DEBUG { ... }`, `INFO { ... }`, `WARN { ... }`, `ERROR { ... }` レベル別ログ
  - [ ] 1段階ネストブロックのパーシング（`LOG { DEBUG { INFO { } } }`）
  - [ ] 2段階以上ネストの検出とエラー報告
- [ ] ログブロック内コード処理
  - [ ] 通常のjvコード実行（変数宣言、関数呼び出し等）
  - [ ] 最後の式または明示的文字列のログメッセージ解釈
  - [ ] 文字列補間のサポート（`"User: $userId"`）
  - [ ] 複数メッセージの連結（改行区切り）

### 11.2 Logger自動生成
- [ ] Loggerフィールド自動挿入
  - [ ] ログ使用クラスへの`private static final Logger`追加
  - [ ] `Logger logger = LoggerFactory.getLogger(ClassName.class);` 生成
  - [ ] 既存Loggerフィールドとの衝突検出
- [ ] フレームワーク抽出化
  - [ ] `jv.toml [logging] framework` に基づくLogger生成
  - [ ] SLF4J: `org.slf4j.LoggerFactory.getLogger()`
  - [ ] Log4j2: `org.apache.logging.log4j.LogManager.getLogger()`
  - [ ] JBoss Logging: `org.jboss.logging.Logger.getLogger()`
  - [ ] Commons Logging: `org.apache.commons.logging.LogFactory.getLog()`
  - [ ] JUL: `java.util.logging.Logger.getLogger()`

### 11.3 コンパイル時最適化
- [ ] log_levelフィルタリング
  - [ ] `jv.toml [logging] log_level` 設定の読み込み
  - [ ] 設定レベル未満のログブロック削除
  - [ ] ネストブロック内コードの条件付き削除
  - [ ] `LOG {}` ブロックの保持（`default_level` に基づく）
- [ ] 条件付きロギング生成
  - [ ] `if (logger.isDebugEnabled())` ガード生成
  - [ ] ネストブロックのガード統合
  - [ ] 不要なガード除去（WARN/ERROR等）

### 11.4 Java変換ルール
- [ ] 基本ログメソッド呼び出し
  - [ ] `LOG { "msg" }` → `logger.info("msg")`（default_levelに基づく）
  - [ ] `DEBUG { "msg" }` → `logger.debug("msg")`
  - [ ] `INFO { "msg" }` → `logger.info("msg")`
  - [ ] `WARN { "msg" }` → `logger.warn("msg")`
  - [ ] `ERROR { "msg" }` → `logger.error("msg")`
  - [ ] `TRACE { "msg" }` → `logger.trace("msg")`
- [ ] ネストブロック展開
  - [ ] 親ブロックのガード条件適用
  - [ ] 子ブロックの独立したガード生成
  - [ ] ネスト内通常コードの保持
- [ ] 文字列補間変換
  - [ ] `$変数` → SLF4J `{}` プレースホルダー
  - [ ] `${式}` → 式評価後プレースホルダー
  - [ ] 引数配列の自動生成

### 11.5 jv.toml設定処理
- [ ] ロギング設定セクション
  - [ ] `[logging] framework` - フレームワーク選択
  - [ ] `[logging] log_level` - コンパイル時ログレベル
  - [ ] `[logging] default_level` - LOG{} のデフォルトレベル
- [ ] フレームワーク固有設定
  - [ ] `[logging.slf4j]` - SLF4J設定
  - [ ] `[logging.log4j2]` - Log4j2設定
  - [ ] 各フレームワークのfactory_class/logger_class/factory_method
- [ ] OpenTelemetry統合設定
  - [ ] `[logging.opentelemetry] enabled` - OTel統合有効化
  - [ ] `[logging.opentelemetry] endpoint` - OTLPエンドポイント
  - [ ] `[logging.opentelemetry] protocol` - grpc/http
  - [ ] `[logging.opentelemetry] trace_context` - トレースコンテキスト自動注入
  - [ ] `[logging.opentelemetry.resource]` - リソース属性
  - [ ] `[logging.opentelemetry.attributes]` - カスタム属性

### 11.6 OpenTelemetry統合
- [ ] Appender/Handler設定自動生成
  - [ ] Logback: `logback.xml` 生成（OpenTelemetryAppender追加）
  - [ ] Log4j2: `log4j2.xml` 生成（OpenTelemetryAppender追加）
  - [ ] JUL: `logging.properties` 生成（OpenTelemetryHandler追加）
- [ ] 依存関係自動追加
  - [ ] `opentelemetry-api` ライブラリ
  - [ ] `opentelemetry-sdk` ライブラリ
  - [ ] `opentelemetry-exporter-otlp` ライブラリ
  - [ ] フレームワーク別instrumentation（logback/log4j2/jul）
- [ ] トレースコンテキスト注入
  - [ ] MDC/NDCへのtraceId/spanId自動注入
  - [ ] ログ出力へのコンテキスト含有
  - [ ] Baggage伝播サポート

### 11.7 環境別設定
- [ ] 環境固有tomlファイル
  - [ ] `jv-dev.toml` - 開発環境（log_level=DEBUG）
  - [ ] `jv-production.toml` - 本番環境（log_level=INFO）
  - [ ] `jv-minimal.toml` - 最小ログ環境（log_level=ERROR）
- [ ] ビルド時設定切り替え
  - [ ] `jv build --config=jv-production.toml` CLIサポート
  - [ ] 環境変数による設定オーバーライド

### 11.8 エラー処理
- [ ] 構文エラー検出
  - [ ] 2段階以上ネストの禁止エラー
  - [ ] ログブロック外でのログキーワード使用エラー
  - [ ] 不正なログレベル指定エラー
- [ ] 設定検証
  - [ ] 未知のframeworkエラー
  - [ ] 不正なlog_level値エラー
  - [ ] OpenTelemetry設定不足エラー
- [ ] エラーメッセージ
  - [ ] 修正候補の提示
  - [ ] 設定例の表示

### 11.9 LSP補完サポート
- [ ] ログブロックスニペット
  - [ ] `LOG` → `LOG { "message" }` スニペット
  - [ ] `DEBUG` → `DEBUG { "message" }` スニペット
  - [ ] ネストパターンスニペット
- [ ] 設定補完
  - [ ] `jv.toml` 内 `[logging]` セクション補完
  - [ ] framework値補完（slf4j/log4j2/jboss-logging等）
  - [ ] log_level値補完（TRACE/DEBUG/INFO/WARN/ERROR/OFF）

### 11.10 テスト
- [ ] パーシングテスト
  - [ ] 基本ログブロック構文
  - [ ] ネストブロック（1段階）
  - [ ] 2段階以上ネストのエラー
  - [ ] 文字列補間
- [ ] 変換テスト
  - [ ] Logger自動生成
  - [ ] フレームワーク別コード生成
  - [ ] log_levelフィルタリング
  - [ ] ネストブロック展開
- [ ] 統合テスト
  - [ ] SLF4J + Logback実行テスト
  - [ ] OpenTelemetry統合テスト
  - [ ] 環境別設定切り替えテスト

---

## 12. テストフレームワーク統合

### 12.1 JUnit 5統合（作業指示書 §1）
- [ ] 基本テスト構文
  - [ ] `test "name" { ... }` → `@Test` + `@DisplayName` 変換
  - [ ] テストメソッド名生成ルール（`test_<名前>`）
  - [ ] アサーション式 `expr == value` → `assertEquals(value, expr)` 自動変換
  - [ ] `@BeforeEach`, `@AfterEach` 標準アノテーション透過的サポート
- [ ] パラメータ化テスト
  - [ ] `test "name" [data] { input, expected -> ... }` 構文パース
  - [ ] `@ParameterizedTest` + `@MethodSource` 生成
  - [ ] データソースメソッド自動生成（`<testname>_source()`）
  - [ ] 配列リテラル → `Stream<Arguments>` 変換
- [ ] データ駆動テスト
  - [ ] `@Sample("file.json")` アノテーション処理
  - [ ] JSON/YAMLファイル読み込み
  - [ ] POJOクラス自動生成（サンプルデータから型推論）
  - [ ] `{ sample -> }` パラメータ注入

### 12.2 Testcontainers統合（作業指示書 §2）
- [ ] 基本コンテナ管理
  - [ ] `with <container>` 構文 → try-with-resources変換
  - [ ] 単一コンテナ `with postgres { source -> ... }`
  - [ ] 複数コンテナ `with [postgres, redis] { (db, cache) -> ... }` 分解受け取り
  - [ ] パラメータ型推論（postgres → DataSource等）
- [ ] コンテナ依存関係
  - [ ] `:=` 演算子 → `dependsOn()` 変換
  - [ ] 自動依存推論（server → postgres, browser → server等）
  - [ ] 配列への依存 `[chrome, firefox] := server`
  - [ ] 並列起動最適化（仮想スレッド活用）
- [ ] コンテナ型自動検出
  - [ ] 組み込みコンテナ（postgres, mysql, redis, kafka等）
  - [ ] カスタムコンテナ（jv.toml `[test.containers]` 定義）
  - [ ] 環境変数自動注入（DATABASE_URL等）
- [ ] LSP補完サポート
  - [ ] `with postgres` → `{ source -> }` スニペット
  - [ ] `with [postgres, redis]` → `{ (db, cache) -> }` スニペット
  - [ ] パラメータ型ヒント表示

### 12.3 Playwright統合（作業指示書 §3）
- [ ] 基本ブラウザテスト
  - [ ] `with browser { page -> ... }` 構文
  - [ ] Playwright自動管理（create → launch → newPage）
  - [ ] ブラウザ指定 `with chrome`, `with firefox`, `with safari`
- [ ] クロスブラウザテスト
  - [ ] `with [chrome, firefox, safari] { browsers -> ... }` 配列受け取り
  - [ ] 並列ブラウザ起動
  - [ ] スクリーンショット自動生成
- [ ] ブラウザ固有機能
  - [ ] `with (chrome, firefox) { (c, f) -> ... }` 分解受け取り
  - [ ] ブラウザ別Page操作
  - [ ] デバイスエミュレーション
- [ ] 統合テスト
  - [ ] `with [postgres, server, browser]` フルスタック
  - [ ] 自動依存関係（browser → server → postgres）
  - [ ] E2Eテストワークフロー

### 12.4 Pact契約テスト統合（作業指示書 §4）
- [ ] Consumer側テスト
  - [ ] `@PactSample` アノテーション処理
  - [ ] `request`/`response` パラメータ解析
  - [ ] JSONサンプルファイル読み込み
  - [ ] `{ (req, res) -> ... }` リクエスト/レスポンス注入
- [ ] Provider自動推論
  - [ ] 優先度1: ディレクトリ構造から推論（`test/contracts/{provider}/`）
  - [ ] 優先度2: レスポンスファイルパスから推論
  - [ ] 優先度3: リクエストパスから推論
  - [ ] 優先度4: jv.toml `[pact] default-provider`
  - [ ] 優先度5: 明示的指定（推論失敗時）
  - [ ] 推論失敗時のエラーメッセージと修正提案
- [ ] Consumer自動推論
  - [ ] jv.toml `[package] name` から自動取得
  - [ ] 明示的指定オプション
- [ ] Pact生成
  - [ ] `@Pact` アノテーション生成
  - [ ] `RequestResponsePact` ビルダー生成
  - [ ] PactDslJsonBody生成（JSONサンプルから）
  - [ ] パスパラメータ/クエリパラメータ対応
- [ ] 統合パターン
  - [ ] `@PactSample(inject="api")` カスタム注入名
  - [ ] `with [postgres, api]` Pact + DB
  - [ ] `with [postgres, api, browser]` Pact + DB + Browser
  - [ ] `with` 句省略（`@PactSample` 単独使用）
- [ ] Provider側テスト
  - [ ] `verifyPact()` 生成
  - [ ] 状態セットアップ（`given`）
  - [ ] 実サーバー検証
- [ ] LSP補完サポート
  - [ ] `@PactSample` → `{ (req, res) -> }` スニペット
  - [ ] Provider推論結果表示
  - [ ] `inject` 指定時の `with` 句提案

### 12.5 Mockito統合（作業指示書 §5）
- [ ] 基本モック作成
  - [ ] `with mock<Type> { mock -> ... }` 構文
  - [ ] `@Mock` アノテーション生成
  - [ ] `@ExtendWith(MockitoExtension.class)` 自動追加
  - [ ] 複数モック `with [mock<T1>, mock<T2>] { (m1, m2) -> ... }`
- [ ] モック振る舞い定義
  - [ ] `.returns(value)` → `when(...).thenReturn(value)`
  - [ ] `.throws(exception)` → `when(...).thenThrow(exception)`
  - [ ] `.calls { ... }` → `when(...).thenAnswer(...)`
  - [ ] 引数マッチャー `any()`, `eq()`, `argThat()`, `capture()`
  - [ ] 連続呼び出し `.returns(v1).returns(v2)`
- [ ] モック検証
  - [ ] `.wasCalled()` → `verify(mock).method(...)`
  - [ ] `.wasCalled(n)` → `verify(mock, times(n)).method(...)`
  - [ ] `.wasNeverCalled()` → `verify(mock, never()).method(...)`
  - [ ] `.wasCalledOnce()` → `verify(mock, times(1)).method(...)`
  - [ ] 引数検証 `.wasCalledWith(...)`
  - [ ] 呼び出し順序検証 `InOrder`
- [ ] スパイ（部分モック）
  - [ ] `with spy<Type> { spy -> ... }` 構文
  - [ ] `@Spy` アノテーション生成
  - [ ] 実装の一部だけモック化
- [ ] カスタム注入キーワード
  - [ ] `@Mock(inject = "repo")` → `with repo<Type> { repo -> ... }`
  - [ ] デフォルトキーワード `mock`, `spy`
- [ ] 他リソースとの統合
  - [ ] `with [postgres, mock<Type>]` DB + モック
  - [ ] `with [browser, mock<Type>]` ブラウザ + モック
  - [ ] `@PactSample(inject="api")` + `with [api, mock<Type>]` Pact + モック
- [ ] LSP補完サポート
  - [ ] `with mock<` → 型補完
  - [ ] `.returns()`, `.throws()`, `.wasCalled()` メソッド補完
  - [ ] 引数マッチャー補完

### 12.6 統一構文システム
- [ ] `test` 構文の完全な形式
  - [ ] 基本形 `test "name" { ... }`
  - [ ] パラメータ化 `test "name" [data] { ... }`
  - [ ] 単一リソース `test "name" with resource { param -> ... }`
  - [ ] 配列リソース `test "name" with [r1, r2] { params -> ... }`
  - [ ] 分解受け取り `test "name" with [r1, r2] { (p1, p2) -> ... }`
  - [ ] 依存関係 `test "name" with [r1, r2 := r1] { ... }`
- [ ] アノテーション規則
  - [ ] `@Sample` - データサンプル（with句不要）
  - [ ] `@PactSample` - API契約（単独時with句不要）
  - [ ] `@Mock` - モック注入キーワード変更（with句必要）
- [ ] パラメータ受け取りパターン
  - [ ] `{ param -> }` 単一パラメータ
  - [ ] `{ params -> }` 配列受け取り
  - [ ] `{ (a, b, c) -> }` 分解受け取り
  - [ ] `{ mockServer -> }` MockServer（Pact既存クライアント）
  - [ ] `{ (req, res) -> }` Pact契約テスト
  - [ ] `{ mock -> }` Mockitoモック
  - [ ] `{ spy -> }` Mockitoスパイ
- [ ] 依存関係表現（`:=` 演算子）
  - [ ] 単一依存 `resource2 := resource1`
  - [ ] 複数依存 `resource3 := [resource1, resource2]`
  - [ ] 配列への依存 `[r1, r2, r3] := resource`
  - [ ] 自動推論ルール（server → DB, browser → server）

### 12.7 jv.toml設定
- [ ] テストコンテナ定義
  - [ ] `[test.containers.<name>]` セクション
  - [ ] `image`, `ports`, `env`, `wait-for` 設定
  - [ ] カスタムコンテナ定義
- [ ] Pact設定
  - [ ] `[pact] default-provider` フォールバック設定
  - [ ] Consumer名自動取得（`[package] name`）

### 12.8 エラー処理とLSP補完
- [ ] エラーメッセージ
  - [ ] Provider推論失敗時の詳細エラー
  - [ ] 修正候補の提示
  - [ ] ディレクトリ構造推奨案
- [ ] LSP補完
  - [ ] コンテキスト別スニペット提供
  - [ ] 型推論とヒント表示
  - [ ] 依存関係推論結果表示
  - [ ] リソース名補完

---

## 13. 開発環境統合（基礎）

### 13.1 基本LSP機能拡張
- [ ] 型情報ホバー表示の充実
  - [ ] 推論された型の詳細表示
  - [ ] null安全性情報の表示
  - [ ] ジェネリック型引数の展開表示
- [ ] 診断メッセージの改善
  - [ ] 型エラーの詳細コンテキスト
  - [ ] 修正候補（Quick Fix）の提示
  - [ ] null安全違反の具体的説明
- [ ] シンボル解決の強化
  - [ ] Javaライブラリシンボルへのジャンプ
  - [ ] フレームワークアノテーション認識
  - [ ] インポート自動補完

### 13.2 IDE統合サポート
- [ ] IntelliJ IDEAプラグイン基礎
  - [ ] 構文ハイライト拡張
  - [ ] コード補完候補生成
  - [ ] リファクタリング基本サポート
- [ ] VS Code拡張改善
  - [ ] デバッガアダプタ基本実装
  - [ ] タスク統合（ビルド・テスト）
  - [ ] 問題マッチャー設定
- [ ] Eclipse統合検討
  - [ ] 基本プラグイン仕様策定
  - [ ] ビルドシステム統合方針

### 13.3 型情報エクスポート
- [ ] 型情報データベース生成
  - [ ] コンパイル時型情報収集
  - [ ] シリアライゼーション形式定義
  - [ ] IDE/LSP向けクエリAPI
- [ ] ソースマップ拡張
  - [ ] 型情報埋め込み
  - [ ] null安全性メタデータ
  - [ ] アノテーション情報保持

---

## テスト・品質保証

### 単体テスト
- [x] 型推論エンジンのテストスイート
- [x] null安全解析のテストケース
- [x] パターンマッチングの型検査テスト
- [x] ジェネリック型処理のテスト
- [x] エラーケースの包括的テスト

### 統合テスト
- [x] 複雑な型推論シナリオのテスト
- [x] null安全性とパターンマッチングの組み合わせテスト
- [x] Java相互運用の型安全性テスト
- [x] パフォーマンステスト（大規模ファイル）
- [x] Javaアノテーション認識テスト
  - [ ] 各種nullアノテーションライブラリ統合テスト
  - [ ] アノテーション競合解決テスト
  - [ ] カスタムアノテーション処理テスト

### フレームワーク統合テスト
- [ ] JUnit 5テストコード実行テスト
- [ ] Spring Framework DI統合テスト
- [ ] Mockitoモック生成・検証テスト
- [ ] Bean Validationバリデーションテスト
- [ ] SLF4Jロギング統合テスト
- [ ] 実プロジェクト規模での総合統合テスト

### コード品質
- [ ] 型推論アルゴリズムの時間計算量検証
- [ ] メモリ使用量の最適化
- [ ] 型エラーメッセージの分かりやすさ検証
- [ ] エッジケースの処理確認
- [ ] フレームワーク統合コード生成品質検証

---

## 完了基準

### 機能完了基準
- [x] 基本的な型推論が正常動作（ローカル変数、関数引数・戻り値）
- [x] null安全演算子の静的解析が動作
- [x] `when`式のJava switch変換が正常動作
- [x] 基本的なジェネリック型の推論・検証が動作
- [x] 主要Javaアノテーションの認識・変換が動作
- [ ] JUnit 5基本テストが実行可能
- [ ] Spring Framework基本DIが動作
- [ ] Bean Validation基本制約が動作

### 品質基準
- [x] 型推論精度95%以上（手動型注釈が不要）
- [x] null安全違反の検出率95%以上
- [x] パターンマッチング網羅性検査の正確性
- [x] 型エラーメッセージの分かりやすさ（ユーザビリティテスト）

### パフォーマンス基準
- [ ] 1000行ファイルの型検査が5秒以内
- [ ] メモリ使用量200MB以下（中規模プロジェクト）
- [ ] 型推論キャッシュによる再チェック高速化
- [ ] インクリメンタル型検査の基本機能

### 受け入れテスト
- [x] 複雑なnull安全コードの正しい解析
- [x] ジェネリック型を使った複雑なコードの型推論
- [x] 型エラーの適切な報告と修正提案
- [x] Java標準ライブラリとの型安全な相互運用
- [ ] Spring Bootアプリケーションの基本動作
- [ ] JUnit 5テストスイート実行成功
- [ ] Javaアノテーションベースのフレームワーク連携成功
- [ ] 実用的なバリデーション適用コードの動作

---

## 注意事項・制約

### 実装上の注意
- 型推論の停止性を保証（無限再帰の回避）
- エラーメッセージの分かりやすさを重視
- パフォーマンスよりも型安全性を優先
- 将来的な型システム拡張を考慮した設計

### 既知の制限
- 高階型の部分的サポート（完全実装は後のフェーズ）
- 依存型の基本形式のみ
- 型レベル計算は限定的
- Java相互運用での一部制約

### リスクと対策
- **リスク**: 型推論アルゴリズムの複雑さ
  - **対策**: 段階的実装、豊富なテストケース
- **リスク**: null安全解析の偽陽性・偽陰性
  - **対策**: 実世界コードでの検証、調整機能
- **リスク**: パフォーマンス問題
  - **対策**: プロファイリング、キャッシュ戦略
- **リスク**: Java相互運用の型不整合
  - **対策**: 詳細な型マッピング仕様、テスト強化

### 技術的課題
- Hindley-Milner型推論とnull安全解析の統合
- Java型システムとの適切なマッピング
- 型エラーメッセージの品質向上
- インクリメンタル型検査の効率的実装
- Javaアノテーションパススルーと検証の両立
- jv独自アノテーションとJavaアノテーションの明確な境界
- テストフレームワーク統合の型安全性保証
- DI・バリデーションフレームワークとの統合品質
- LSP/IDE統合での型情報リアルタイム提供

### Javaアノテーション処理方針
- **基本方針**: Javaアノテーションは構文検証後にそのままパススルー
- **jv独自アノテーション**: `@Sample`, `@Unit`, `@Currency`, `@Calendar`, `@Encoding`等はコンパイル時処理
- **検証範囲**:
  - アノテーション位置の妥当性（Java言語仕様準拠）
  - jv予約アノテーションとの名前衝突
  - 同一要素への重複アノテーション
- **特殊処理**: null安全性関連アノテーション（`@Nullable`, `@NonNull`等）は型推論に反映
- **非検証範囲**: アノテーション引数の型正当性（javacに委譲）
