package jv.collections

import java.util.*
import java.util.stream.*

fun <T> Iterable<T>.toStream(): Stream<T> {
    return StreamSupport.stream(
        this.spliterator()
        false
    )
}

fun <T, R> Stream<T>.map(transform: (T) -> R): Stream<R> {
    return this.map { value -> transform(value) }
}

fun <T> Stream<T>.filter(predicate: (T) -> Boolean): Stream<T> {
    return this.filter { value -> predicate(value) }
}

fun <T> Stream<T>.take(count: Int): Stream<T> {
    return this.limit(count)
}

fun <T> Stream<T>.drop(count: Int): Stream<T> {
    return this.skip(count)
}

fun <T, R> Stream<T>.flatMapIterable(transform: (T) -> Iterable<R>): Stream<R> {
    return this.flatMap { value -> transform(value).toStream() }
}

fun <T, R> Stream<T>.flatMapStream(transform: (T) -> Stream<R>): Stream<R> {
    return this.flatMap { value -> transform(value) }
}

fun <T, R : Comparable<R>> Stream<T>.sortedBy(selector: (T) -> R): Stream<T> {
    return this.sorted { left right ->
        selector(left).compareTo(selector(right))
    }
}

fun <T> Stream<T>.toListStream(): List<T> {
    return this.collect(Collectors.toList())
}

fun <T, R> Stream<T>.fold(initial: R, operation: (R, T) -> R): R {
    var accumulator = initial
    this.forEach { value ->
        accumulator = operation(
            accumulator
            value
        )
    }
    return accumulator
}

fun <T> Stream<T>.reduce(operation: (T, T) -> T): Optional<T> {
    return this.reduce { left right ->
        operation(
            left
            right
        )
    }
}

fun <T> Stream<T>.countElements(): Long {
    return this.count()
}

fun Stream<Byte>.sum(): Int {
    val elements : List<Byte> = this.toListStream()
    var total = 0
    for (candidate in elements) {
        total = total + candidate.intValue()
    }
    return total
}

fun Stream<Short>.sum(): Int {
    val elements : List<Short> = this.toListStream()
    var total = 0
    for (candidate in elements) {
        total = total + candidate.intValue()
    }
    return total
}

fun Stream<Int>.sum(): Int {
    val elements : List<Int> = this.toListStream()
    var total = 0
    for (candidate in elements) {
        total = total + candidate
    }
    return total
}

fun Stream<Long>.sum(): Long {
    val elements: List<Long> = this.toListStream()
    var total = 0L
    for (candidate in elements) {
        total = total + candidate.longValue()
    }
    return total
}

fun Stream<Float>.sum(): Float {
    val elements: List<Float> = this.toListStream()
    var total = 0.0f
    for (candidate in elements) {
        total = total + candidate.floatValue()
    }
    return total
}

fun Stream<Double>.sum(): Double {
    val elements: List<Double> = this.toListStream()
    var total = 0.0
    for (candidate in elements) {
        total = total + candidate.doubleValue()
    }
    return total
}

/**
 * Primitive-specialized terminal adapters for raw JDK streams.
 */
fun <T> Stream<T>.sumIntFamily(): Int
    where T : int, T : char, T : short {
    return this
        .mapToInt { candidate ->
            when (candidate is Character) {
                true -> candidate.toString().codePointAt(0)
                else -> (candidate as Number).intValue()
            }
        }
        .sum()
}

fun <T> Stream<T>.sumLongFamily(): Long
    where T : long {
    return this
        .mapToLong { candidate -> (candidate as Number).longValue() }
        .sum()
}

fun <T> Stream<T>.sumFloatFamily(): Float
    where T : float {
    val elements: List<T> = this.toListStream()
    var total = 0.0f
    for (candidate in elements) {
        val numeric = candidate as Number
        total = total + numeric.floatValue()
    }
    return total
}

fun <T> Stream<T>.sumDoubleFamily(): Double
    where T : double {
    val elements: List<T> = this.toListStream()
    var total = 0.0
    for (candidate in elements) {
        val numeric = candidate as Number
        total = total + numeric.doubleValue()
    }
    return total
}

fun <T, R> Iterable<T>.map(transform: (T) -> R): Stream<R> {
    return this.toStream().map { value -> transform(value) }
}

fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): Stream<T> {
    return this.toStream().filter { value -> predicate(value) }
}

fun <T> Iterable<T>.take(count: Int): Stream<T> {
    return this.toStream().limit(count)
}

fun <T> Iterable<T>.drop(count: Int): Stream<T> {
    return this.toStream().skip(count)
}

fun <T, R> Iterable<T>.flatMapIterable(transform: (T) -> Iterable<R>): Stream<R> {
    return this.toStream().flatMap { value -> transform(value).toStream() }
}

fun <T, R> Iterable<T>.flatMapStream(transform: (T) -> Stream<R>): Stream<R> {
    return this.toStream().flatMap { value -> transform(value) }
}

fun <T : Comparable<T>> Iterable<T>.sorted(): Stream<T> {
    return this.toStream().sorted()
}

fun <T, R : Comparable<R>> Iterable<T>.sortedBy(selector: (T) -> R): Stream<T> {
    return this.toStream().sorted { left right ->
        selector(left).compareTo(selector(right))
    }
}

fun <T> Iterable<T>.toList(): List<T> {
    return this.toStream().toListStream()
}

fun <T, R> Iterable<T>.fold(initial: R, operation: (R, T) -> R): R {
    return this.toStream().fold(
        initial
        operation
    )
}

fun <T> Iterable<T>.reduce(operation: (T, T) -> T): Optional<T> {
    return this.toStream().reduce(operation)
}

fun <T> Iterable<T>.countElements(): Long {
    return this.toStream().count()
}

fun Iterable<Byte>.sum(): Int {
    return Sequence.sumIntFamily(Sequence.toStream(this))
}

fun Iterable<Short>.sum(): Int {
    return Sequence.sumIntFamily(Sequence.toStream(this))
}

fun Iterable<Int>.sum(): Int {
    return Sequence.sumIntFamily(Sequence.toStream(this))
}

fun Iterable<Long>.sum(): Long {
    return Sequence.sumLongFamily(Sequence.toStream(this))
}

fun Iterable<Float>.sum(): Float {
    return Sequence.sumFloatFamily(Sequence.toStream(this))
}

fun Iterable<Double>.sum(): Double {
    return Sequence.sumDoubleFamily(Sequence.toStream(this))
}

fun <T> Iterable<T>.forEach(action: (T) -> Unit) {
    this.toStream().forEach { value -> action(value) }
}

fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {
    val result = LinkedHashMap<K, List<T>>()
    for (element in this) {
        val key = keySelector(element)
        val bucket = result.computeIfAbsent(key) { ArrayList<T>() }
        bucket.add(element)
    }
    return result
}

fun <T, K, V> Iterable<T>.associate(transform: (T) -> Map.Entry<K, V>): Map<K, V> {
    val result = LinkedHashMap<K, V>()
    for (element in this) {
        val entry = transform(element)
        result.put(entry.getKey(), entry.getValue())
    }
    return result
}
