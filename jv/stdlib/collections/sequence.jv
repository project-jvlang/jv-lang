package jv.collections

import java.util.*
import java.util.stream.*

fun <T> Iterable<T>.toStream(): Stream<T> {
    return StreamSupport.stream(
        this.spliterator()
        false
    )
}

fun <T, R> Stream<T>.map(transform: (T) -> R): Stream<R> {
    return this.map { value -> transform(value) }
}

fun <T> Stream<T>.filter(predicate: (T) -> Boolean): Stream<T> {
    return this.filter { value -> predicate(value) }
}

fun <T> Stream<T>.take(count: Int): Stream<T> {
    return this.limit(count + 0L)
}

fun <T> Stream<T>.drop(count: Int): Stream<T> {
    return this.skip(count + 0L)
}

fun <T, R> Stream<T>.flatMapIterable(transform: (T) -> Iterable<R>): Stream<R> {
    return this.flatMap { value -> transform(value).toStream() }
}

fun <T, R> Stream<T>.flatMapStream(transform: (T) -> Stream<R>): Stream<R> {
    return this.flatMap { value -> transform(value) }
}

fun <T, R : Comparable<R>> Stream<T>.sortedBy(selector: (T) -> R): Stream<T> {
    return this.sorted { left right ->
        val leftKey : R = selector(left)
        val rightKey : R = selector(right)
        leftKey.compareTo(rightKey)
    }
}

fun <T> Stream<T>.toListStream(): List<T> {
    return this.collect(Collectors.toList())
}

fun <T, R> Stream<T>.fold(initial: R, operation: (R, T) -> R): R {
    var accumulator = initial
    this.forEach { value ->
        accumulator = operation(
            accumulator
            value
        )
    }
    return accumulator
}

fun <T> Stream<T>.reduce(operation: (T, T) -> T): T {
    val reduced = this.reduce { left right ->
        operation(
            left
            right
        )
    }
    return reduced.orElseThrow { IllegalArgumentException("Stream reduce() on empty source") }
}

fun <T> Stream<T>.countElements(): Long {
    return this.count()
}

fun Stream<Byte>.sum(): Int {
    val elements : List<Byte> = this.toListStream()
    var total = 0
    for (candidate in elements) {
        total = total + candidate.intValue()
    }
    return total
}

fun Stream<Short>.sum(): Int {
    val elements : List<Short> = this.toListStream()
    var total = 0
    for (candidate in elements) {
        total = total + candidate.intValue()
    }
    return total
}

fun Stream<Int>.sum(): Int {
    val elements : List<Int> = this.toListStream()
    var total = 0
    for (candidate in elements) {
        total = total + candidate
    }
    return total
}

fun Stream<Long>.sum(): Long {
    val elements : List<Long> = this.toListStream()
    var total = 0L
    for (candidate in elements) {
        total = total + candidate
    }
    return total
}

fun Stream<Float>.sum(): Float {
    val elements : List<Float> = this.toListStream()
    var total = 0.0f
    for (candidate in elements) {
        total = total + candidate
    }
    return total
}

fun Stream<Double>.sum(): Double {
    val elements : List<Double> = this.toListStream()
    var total = 0.0
    for (candidate in elements) {
        total = total + candidate
    }
    return total
}

/**
 * Primitive-specialized terminal adapters for raw JDK streams.
 */
fun <T> Stream<T>.sumIntFamily(): Int
    where T : int, T : char, T : short {
    return this
        .mapToInt { candidate -> normalizeIntFamilyValue(candidate) }
        .sum()
}

fun <T> Stream<T>.sumLongFamily(): Long
    where T : long {
    return this
        .mapToLong { candidate -> candidate.longValue() }
        .sum()
}

fun <T> Stream<T>.sumFloatFamily(): Float
    where T : float {
    val elements : List<T> = this.toListStream()
    var total = 0.0f
    for (candidate in elements) {
        total = total + candidate
    }
    return total
}

fun <T> Stream<T>.sumDoubleFamily(): Double
    where T : double {
    val elements : List<T> = this.toListStream()
    var total = 0.0
    for (candidate in elements) {
        total = total + candidate
    }
    return total
}

fun <T, R> Iterable<T>.map(transform: (T) -> R): Stream<R> {
    return this.toStream().map { value -> transform(value) }
}

fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): Stream<T> {
    return this.toStream().filter { value -> predicate(value) }
}

fun <T> Iterable<T>.take(count: Int): Stream<T> {
    return this.toStream().limit(count + 0L)
}

fun <T> Iterable<T>.drop(count: Int): Stream<T> {
    return this.toStream().skip(count + 0L)
}

fun <T, R> Iterable<T>.flatMapIterable(transform: (T) -> Iterable<R>): Stream<R> {
    return this.toStream().flatMap { value -> transform(value).toStream() }
}

fun <T, R> Iterable<T>.flatMapStream(transform: (T) -> Stream<R>): Stream<R> {
    return this.toStream().flatMap { value -> transform(value) }
}

fun <T : Comparable<T>> Iterable<T>.sorted(): Stream<T> {
    return this.toStream().sorted()
}

fun <T, R : Comparable<R>> Iterable<T>.sortedBy(selector: (T) -> R): Stream<T> {
    return this.toStream().sorted { left right ->
        val leftKey : R = selector(left)
        val rightKey : R = selector(right)
        leftKey.compareTo(rightKey)
    }
}

fun <T> Iterable<T>.toList(): List<T> {
    return this.toStream().toListStream()
}

fun <T, R> Iterable<T>.fold(initial: R, operation: (R, T) -> R): R {
    return this.toStream().fold(
        initial
        operation
    )
}

fun <T> Iterable<T>.reduce(operation: (T, T) -> T): T {
    return this.toStream().reduce(operation)
}

fun <T> Iterable<T>.countElements(): Long {
    return this.toStream().count()
}

fun Iterable<Byte>.sum(): Int {
    return Sequence.sumIntFamily(Sequence.toStream(this))
}

fun Iterable<Short>.sum(): Int {
    return Sequence.sumIntFamily(Sequence.toStream(this))
}

fun Iterable<Int>.sum(): Int {
    return Sequence.sumIntFamily(Sequence.toStream(this))
}

fun Iterable<Long>.sum(): Long {
    return Sequence.sumLongFamily(Sequence.toStream(this))
}

fun Iterable<Float>.sum(): Float {
    return Sequence.sumFloatFamily(Sequence.toStream(this))
}

fun Iterable<Double>.sum(): Double {
    return Sequence.sumDoubleFamily(Sequence.toStream(this))
}

fun <T> Iterable<T>.forEach(action: (T) -> Unit) {
    this.toStream().forEach { value -> action(value) }
}

fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {
    var result = LinkedHashMap<K, List<T>>()
    val elements : List<T> = this.toList()
    for (element in elements) {
        val key = keySelector(element)
        var bucket = result.get(key)
        when (bucket == null) {
            true -> {
                bucket = ArrayList<T>()
                result.put(
                    key
                    bucket
                )
            }
            else -> {}
        }
        bucket.add(element)
    }
    return result
}

fun <T, K, V> Iterable<T>.associate(transform: (T) -> Map.Entry<K, V>): Map<K, V> {
    var result = LinkedHashMap<K, V>()
    val elements : List<T> = this.toList()
    for (element in elements) {
        val entry = transform(element)
        result.put(
            entry.getKey()
            entry.getValue()
        )
    }
    return result
}

private fun <T> normalizeIntFamilyValue(value: T): Int
    where T : int, T : char, T : short {
    when (value is Character) {
        true -> {
            val character = value as Character
            val raw = character.charValue()
            return raw + 0
        }
        else -> {
            val number = value as Number
            return number.intValue()
        }
    }
}
