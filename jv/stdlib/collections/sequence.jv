package jv.collections

import java.util.*
import java.util.stream.*

/**
 * SequenceCore は Java Stream を直接保持する最小限の遅延チェーンコンテナ。
 */
data SequenceCore<T>(stream: Stream<T>)

/**
 * SequenceCore を生成するためのトップレベルファクトリ。
 *
 * stdlib 内部で Iterable/Stream から遅延チェーンを開始する用途に限定し、
 * Zero runtime 原則に従って JDK Stream 以外の補助ランタイムを導入しないことを明記する。
 */

fun <T> sequenceFromIterable(source: Iterable<T>): SequenceCore<T> {
    val stream : Stream<T> = StreamSupport.stream(
        source.spliterator()
        false
    )
    return SequenceCore(stream)
}

fun <T> sequenceFromStream(stream: Stream<T>): SequenceCore<T> {
    return SequenceCore(stream)
}

fun <T> SequenceCore<T>.iterator(): Iterator<T> {
    return this.stream.iterator()
}

fun <T> SequenceCore<T>.close() {
    this.stream.close()
}

/**
 * Kotlin `Sequence.map` と同等の変換操作。
 */
fun <T, R> SequenceCore<T>.map(transform: (T) -> R): SequenceCore<R> {
    return this.stream.map { value -> transform(value) }
}

/**
 * Kotlin `Sequence.filter` と同等のフィルタ操作。
 */
fun <T> SequenceCore<T>.filter(predicate: (T) -> Boolean): SequenceCore<T> {
    return this.stream.filter { value -> predicate(value) }
}

/**
 * Kotlin `Sequence.take` と同等の範囲制御操作。
 */
fun <T> SequenceCore<T>.take(count: Int): SequenceCore<T> {
    return sequenceFromStream(
        this.stream.limit(count)
    )
}

/**
 * Kotlin `Sequence.drop` と同等のスキップ操作。
 */
fun <T> SequenceCore<T>.drop(count: Int): SequenceCore<T> {
    return sequenceFromStream(
        this.stream.skip(count)
    )
}

/**
 * Kotlin `Sequence.flatMap` と同等のフラット化操作。
 */
fun <T, R> SequenceCore<T>.flatMap(transform: (T) -> Iterable<R>): SequenceCore<R> {
    return this.stream.flatMap { value ->
        StreamSupport.stream(
            transform(value).spliterator()
            false
        )
    }
}

fun <T, R> SequenceCore<T>.flatMap(transform: (T) -> Stream<R>): SequenceCore<R> {
    return this.stream.flatMap(transform)
}

/**
 * Kotlin `Sequence.sorted` と同等のソート操作。
 */
fun <T : Comparable<T>> SequenceCore<T>.sorted(): SequenceCore<T> {
    return this.stream.sorted()
}

/**
 * Kotlin `Sequence.sortedBy` と同等のキー指定ソート。
 */
fun <T, R : Comparable<R>> SequenceCore<T>.sortedBy(selector: (T) -> R): SequenceCore<T> {
    return this.stream.sorted { left right ->
        selector(left).compareTo(selector(right))
    }
}

/**
 * Kotlin `Sequence.toList` と同等の終端操作。
 */
fun <T> SequenceCore<T>.toList(): List<T> {
    return this.stream.toList()
}

/**
 * Kotlin `Sequence.fold` と同等の集約操作。
 */
fun <T, R> SequenceCore<T>.fold(initial: R, operation: (R, T) -> R): R {
    return this.stream.reduce(initial) { accumulator value ->
        operation(
            accumulator
            value
        )
    }
}

/**
 * Kotlin `Sequence.reduce` と同等の集約操作。
 */
fun <T> SequenceCore<T>.reduce(operation: (T, T) -> T): T {
    val reduced : T = this.stream.reduce { left right ->
        operation(
            left
            right
        )
    }

    return reduced
}

/**
 * Kotlin `Sequence.count` に対応する要素数集計。
 */
fun <T> SequenceCore<T>.count(): Long {
    return this.stream.count()
}

/**
 * Kotlin `Sequence.sum` に対応する型別集約。
 */
fun SequenceCore<Byte>.sum(): Int {
    val elements : List<Byte> = this.toList()
    var total = 0
    for (candidate in elements) {
        total = total + candidate.intValue()
    }
    return total
}

fun SequenceCore<Short>.sum(): Int {
    val elements : List<Short> = this.toList()
    var total = 0
    for (candidate in elements) {
        total = total + candidate.intValue()
    }
    return total
}

fun SequenceCore<Int>.sum(): Int {
    val elements : List<Int> = this.toList()
    var total = 0
    for (candidate in elements) {
        total = total + candidate
    }
    return total
}

fun SequenceCore<Long>.sum(): Long {
    val elements : List<Long> = this.toList()
    var total = 0L
    for (candidate in elements) {
        total = total + candidate
    }
    return total
}

fun SequenceCore<Float>.sum(): Float {
    val elements : List<Float> = this.toList()
    var total = 0.0f
    for (candidate in elements) {
        total = total + candidate
    }
    return total
}

fun SequenceCore<Double>.sum(): Double {
    val elements : List<Double> = this.toList()
    var total = 0.0
    for (candidate in elements) {
        total = total + candidate
    }
    return total
}

/**
 * Primitive-specialized terminal adapters for raw JDK streams used by SequenceCore bridging.
 *
 * The generic constraints rely on primitive bounds so that `Stream<Int>` as well as
 * alias families (`Stream<Char>`, `Stream<Short>`, etc.) share the same UX.
 */
fun <T> Stream<T>.sum(): Int
    where T : int, T : char, T : short {
    return this
        .mapToInt { candidate -> candidate }
        .sum()
}

fun <T> Stream<T>.sum(): Long
    where T : long {
    return this
        .mapToLong { candidate -> candidate }
        .sum()
}

fun <T> Stream<T>.sum(): Float
    where T : float {
    val identity = 0.0f
    val accumulated = this.reduce(
        identity
        { running value -> running + value }
    )
    return accumulated
}

fun <T> Stream<T>.sum(): Double
    where T : double {
    val identity = 0.0
    val accumulated = this.reduce(
        identity
        { running value -> running + value }
    )
    return accumulated
}

/**
 * Kotlin `Sequence.forEach` と同等の副作用操作。
 */
fun <T> SequenceCore<T>.forEach(action: (T) -> Unit) {
    this.stream.forEach { value -> action(value) }
}

/**
 * Kotlin `Sequence.groupBy` と同等のキー集約操作。
 */
fun <T, K> SequenceCore<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {
    var result = LinkedHashMap<K, List<T>>()
    val elements : List<T> = this.toList()
    for (element in elements) {
        val key = keySelector(element)

        var bucket = result.get(key)
        when (bucket == null) {
            true -> {
                bucket = ArrayList()
                result.put(
                    key
                    bucket
                )
            }
            else -> {}
        }

        bucket.add(element)
    }
    return result
}

/**
 * Kotlin `Sequence.associate` と同等のキー／値マップ生成。
 */
fun <T, K, V> SequenceCore<T>.associate(transform: (T) -> Map.Entry<K, V>): Map<K, V> {
    var result = LinkedHashMap<K, V>()
    val elements : List<T> = this.toList()
    for (element in elements) {
        val entry = transform(element)
        result.put(
            entry.getKey()
            entry.getValue()
        )
    }
    return result
}

/**
 * コレクションから Kotlin `Sequence.map` 相当の遅延チェーンを開始する拡張。
 */
fun <T, R> Iterable<T>.map(transform: (T) -> R): SequenceCore<R> {
    return sequenceFromIterable(this).map(transform)
}

/**
 * コレクションから Kotlin `Sequence.filter` 相当の遅延チェーンを開始する拡張。
 */
fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): SequenceCore<T> {
    return sequenceFromIterable(this).filter(predicate)
}

/**
 * コレクションから Kotlin `Sequence.take` 相当の遅延チェーンを開始する拡張。
 */
fun <T> Iterable<T>.take(count: Int): SequenceCore<T> {
    return sequenceFromIterable(this).take(count)
}

/**
 * コレクションから Kotlin `Sequence.drop` 相当の遅延チェーンを開始する拡張。
 */
fun <T> Iterable<T>.drop(count: Int): SequenceCore<T> {
    return sequenceFromIterable(this).drop(count)
}

/**
 * コレクションから Kotlin `Sequence.flatMap` 相当の遅延チェーンを開始する拡張。
 */
fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): SequenceCore<R> {
    return sequenceFromIterable(this).flatMap(transform)
}

fun <T, R> Iterable<T>.flatMap(transform: (T) -> Stream<R>): SequenceCore<R> {
    return sequenceFromIterable(this).flatMap(transform)
}

/**
 * Kotlin `Iterable.sorted` に準拠した遅延ソート開始。
 */
fun <T : Comparable<T>> Iterable<T>.sorted(): SequenceCore<T> {
    return sequenceFromIterable(this).sorted()
}

/**
 * Kotlin `Iterable.sortedBy` に準拠したキー指定ソートの遅延チェーン。
 */
fun <T, R : Comparable<R>> Iterable<T>.sortedBy(selector: (T) -> R): SequenceCore<R> {
    return sequenceFromIterable(this).sortedBy(selector)
}

/**
 * Kotlin `Iterable.fold` と同等の集約操作。
 */
fun <T, R> Iterable<T>.fold(initial: R, operation: (R, T) -> R): R {
    return sequenceFromIterable(this).fold(
        initial
        operation
    )
}

/**
 * Kotlin `Iterable.reduce` と同等の集約操作。
 */
fun <T> Iterable<T>.reduce(operation: (T, T) -> T): T {
    return sequenceFromIterable(this).reduce(operation)
}

/**
 * Kotlin `Iterable.count` と同等の要素数集計。
 */
fun <T> Iterable<T>.count(): Long {
    return sequenceFromIterable(this).count()
}

/**
 * 任意の射影関数を介して数値を抽出し、同じ型で合計する汎用集約。
 */
/**
 * Kotlin `Iterable.sum` に対応する型別集約。
 */
fun Iterable<Byte>.sum(): Int {
    var total = 0
    for (candidate in this) {
        total = total + candidate.intValue()
    }
    return total
}

fun Iterable<Short>.sum(): Int {
    var total = 0
    for (candidate in this) {
        total = total + candidate.intValue()
    }
    return total
}

fun Iterable<Int>.sum(): Int {
    var total = 0
    for (candidate in this) {
        total = total + candidate
    }
    return total
}

fun Iterable<Long>.sum(): Long {
    var total = 0L
    for (candidate in this) {
        total = total + candidate
    }
    return total
}

fun Iterable<Float>.sum(): Float {
    var total = 0.0f
    for (candidate in this) {
        total = total + candidate
    }
    return total
}

fun Iterable<Double>.sum(): Double {
    var total = 0.0
    for (candidate in this) {
        total = total + candidate
    }
    return total
}

/**
 * Kotlin `Iterable.forEach` と同等の副作用操作。
 */
fun <T> Iterable<T>.forEach(action: (T) -> Unit) {
    sequenceFromIterable(this).forEach(action)
}

/**
 * Kotlin `Iterable.groupBy` と同等のマップ生成。
 */
fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {
    return sequenceFromIterable(this).groupBy(keySelector)
}

/**
 * Kotlin `Iterable.associate` と同等のキー／値マップ生成。
 */
fun <T, K, V> Iterable<T>.associate(transform: (T) -> Map.Entry<K, V>): Map<K, V> {
    return sequenceFromIterable(this).associate(transform)
}
