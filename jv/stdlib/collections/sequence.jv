package jv.collections

import java.lang.IllegalArgumentException
import java.util.ArrayList
import java.util.Comparator
import java.util.Iterator
import java.util.LinkedHashMap
import java.util.List
import java.util.Map
import java.util.stream.Stream

/**
 * SequenceCore は Java Stream を直接保持する最小限の遅延チェーンコンテナ。
 */
data SequenceCore<T>(stream: Stream<T>)

/**
 * SequenceCore を生成するためのトップレベルファクトリ。
 *
 * stdlib 内部で Iterable/Stream から遅延チェーンを開始する用途に限定し、
 * Zero runtime 原則に従って JDK Stream 以外の補助ランタイムを導入しないことを明記する。
 */

fun <T> sequenceFromIterable(source: Iterable<T>): SequenceCore<T> {
    val stream: Stream<T> = java.util.stream.StreamSupport.stream(
        source.spliterator()
        false
    )
    return SequenceCore(stream)
}

fun <T> sequenceFromStream(stream: Stream<T>): SequenceCore<T> {
    return SequenceCore(stream)
}

fun <T> SequenceCore<T>.iterator(): Iterator<T> {
    return this.stream.iterator()
}

fun <T> SequenceCore<T>.close() {
    this.stream.close()
}

fun <T> SequenceCore<T>.toStream(): Stream<T> {
    return this.stream
}

/**
 * Kotlin `Sequence.map` と同等の変換操作。
 */
fun <T, R> SequenceCore<T>.map(transform: (T) -> R): SequenceCore<R> {
    return sequenceFromStream(
        this.toStream().map { value -> transform(value) }
    )
}

/**
 * Kotlin `Sequence.filter` と同等のフィルタ操作。
 */
fun <T> SequenceCore<T>.filter(predicate: (T) -> Boolean): SequenceCore<T> {
    return sequenceFromStream(
        this.toStream().filter { value -> predicate(value) }
    )
}

/**
 * Kotlin `Sequence.take` と同等の範囲制御操作。
 */
fun <T> SequenceCore<T>.take(count: Int): SequenceCore<T> {
    return sequenceFromStream(
        this.toStream().limit(count.toLong())
    )
}

/**
 * Kotlin `Sequence.drop` と同等のスキップ操作。
 */
fun <T> SequenceCore<T>.drop(count: Int): SequenceCore<T> {
    return sequenceFromStream(
        this.toStream().skip(count.toLong())
    )
}

/**
 * Kotlin `Sequence.flatMap` と同等のフラット化操作。
 */
fun <T, R> SequenceCore<T>.flatMap(transform: (T) -> Iterable<R>): SequenceCore<R> {
    return sequenceFromStream(
        this.toStream().flatMap { value ->
            java.util.stream.StreamSupport.stream(
                transform(value).spliterator()
                false
            )
        }
    )
}

fun <T, R> SequenceCore<T>.flatMap(transform: (T) -> SequenceCore<R>): SequenceCore<R> {
    return sequenceFromStream(
        this.toStream().flatMap { value -> transform(value).toStream() }
    )
}

/**
 * Kotlin `Sequence.sorted` と同等のソート操作。
 */
fun <T : Comparable<T>> SequenceCore<T>.sorted(): SequenceCore<T> {
    return sequenceFromStream(this.toStream().sorted())
}

/**
 * Kotlin `Sequence.sortedBy` と同等のキー指定ソート。
 */
fun <T, R : Comparable<R>> SequenceCore<T>.sortedBy(selector: (T) -> R): SequenceCore<T> {
    return sequenceFromStream(
        this.toStream().sorted(
            Comparator.comparing { value -> selector(value) }
        )
    )
}

/**
 * Kotlin `Sequence.toList` と同等の終端操作。
 */
fun <T> SequenceCore<T>.toList(): List<T> {
    return this.toStream().toList()
}

/**
 * Kotlin `Sequence.fold` と同等の集約操作。
 */
fun <T, R> SequenceCore<T>.fold(initial: R, operation: (R, T) -> R): R {
    return this.toStream().reduce(initial) { accumulator value ->
        operation(
            accumulator
            value
        )
    }
}

/**
 * Kotlin `Sequence.reduce` と同等の集約操作。
 */
fun <T> SequenceCore<T>.reduce(operation: (T, T) -> T): T {
    val reduced = this.toStream().reduce { left right ->
        operation(
            left
            right
        )
    }

    return reduced.orElseThrow {
        IllegalArgumentException("Sequence reduce() on empty source")
    }
}

/**
 * Kotlin `Sequence.count` に対応する要素数集計。
 */
fun <T> SequenceCore<T>.count(): Long {
    return this.toStream().count()
}

/**
 * Kotlin `Sequence.sum` 相当の数値集計。
 */
fun SequenceCore<Number>.sum(): Long {
    val elements = Sequence.toList(this)
    var total: Long = 0
    for (candidate in elements) {
        total = total + candidate.longValue()
    }
    return total
}

/**
 * Kotlin `Sequence.forEach` と同等の副作用操作。
 */
fun <T> SequenceCore<T>.forEach(action: (T) -> Unit) {
    this.toStream().forEach { value -> action(value) }
}

/**
 * Kotlin `Sequence.groupBy` と同等のキー集約操作。
 */
fun <T, K> SequenceCore<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {
    val result: LinkedHashMap<K, List<T>> = LinkedHashMap()
    val elements = Sequence.toList(this)
    for (element in elements) {
        val key = keySelector(element)

        var bucket = result.get(key)
        when (bucket == null) {
            true -> {
                bucket = ArrayList()
                result.put(
                    key
                    bucket
                )
            }
            else -> {}
        }

        bucket.add(element)
    }
    return result
}

/**
 * Kotlin `Sequence.associate` と同等のキー／値マップ生成。
 */
fun <T, K, V> SequenceCore<T>.associate(transform: (T) -> Map.Entry<K, V>): Map<K, V> {
    val result: LinkedHashMap<K, V> = LinkedHashMap()
    val elements = Sequence.toList(this)
    for (element in elements) {
        val entry = transform(element)
        result.put(
            entry.getKey()
            entry.getValue()
        )
    }
    return result
}

/**
 * コレクションから Kotlin `Sequence.map` 相当の遅延チェーンを開始する拡張。
 */
fun <T, R> Iterable<T>.map(transform: (T) -> R): SequenceCore<R> {
    return sequenceFromIterable(this).map(transform)
}

/**
 * コレクションから Kotlin `Sequence.filter` 相当の遅延チェーンを開始する拡張。
 */
fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): SequenceCore<T> {
    return sequenceFromIterable(this).filter(predicate)
}

/**
 * コレクションから Kotlin `Sequence.take` 相当の遅延チェーンを開始する拡張。
 */
fun <T> Iterable<T>.take(count: Int): SequenceCore<T> {
    return sequenceFromIterable(this).take(count)
}

/**
 * コレクションから Kotlin `Sequence.drop` 相当の遅延チェーンを開始する拡張。
 */
fun <T> Iterable<T>.drop(count: Int): SequenceCore<T> {
    return sequenceFromIterable(this).drop(count)
}

/**
 * コレクションから Kotlin `Sequence.flatMap` 相当の遅延チェーンを開始する拡張。
 */
fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): SequenceCore<R> {
    return sequenceFromIterable(this).flatMap(transform)
}

fun <T, R> Iterable<T>.flatMap(transform: (T) -> SequenceCore<R>): SequenceCore<R> {
    return sequenceFromIterable(this).flatMap(transform)
}

/**
 * Kotlin `Iterable.sorted` に準拠した遅延ソート開始。
 */
fun <T : Comparable<T>> Iterable<T>.sorted(): SequenceCore<T> {
    return sequenceFromIterable(this).sorted()
}

/**
 * Kotlin `Iterable.sortedBy` に準拠したキー指定ソートの遅延チェーン。
 */
fun <T, R : Comparable<R>> Iterable<T>.sortedBy(selector: (T) -> R): SequenceCore<T> {
    return sequenceFromIterable(this).sortedBy(selector)
}

/**
 * Kotlin `Iterable.fold` と同等の集約操作。
 */
fun <T, R> Iterable<T>.fold(initial: R, operation: (R, T) -> R): R {
    return sequenceFromIterable(this).fold(
        initial
        operation
    )
}

/**
 * Kotlin `Iterable.reduce` と同等の集約操作。
 */
fun <T> Iterable<T>.reduce(operation: (T, T) -> T): T {
    return sequenceFromIterable(this).reduce(operation)
}

/**
 * Kotlin `Iterable.count` と同等の要素数集計。
 */
fun <T> Iterable<T>.count(): Long {
    return sequenceFromIterable(this).count()
}

/**
 * Kotlin `Iterable.sum` と同等の数値集計。
 */
fun <T> Iterable<T>.sum(): Long {
    return sequenceFromIterable(this).sum()
}

/**
 * Kotlin `Iterable.forEach` と同等の副作用操作。
 */
fun <T> Iterable<T>.forEach(action: (T) -> Unit) {
    sequenceFromIterable(this).forEach(action)
}

/**
 * Kotlin `Iterable.groupBy` と同等のマップ生成。
 */
fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {
    return sequenceFromIterable(this).groupBy(keySelector)
}

/**
 * Kotlin `Iterable.associate` と同等のキー／値マップ生成。
 */
fun <T, K, V> Iterable<T>.associate(transform: (T) -> Map.Entry<K, V>): Map<K, V> {
    return sequenceFromIterable(this).associate(transform)
}
