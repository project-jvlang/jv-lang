package jv.collections

import java.lang.IllegalArgumentException
import java.util.ArrayList
import java.util.Comparator
import java.util.Iterator
import java.util.LinkedHashMap
import java.util.List
import java.util.Map
import java.util.stream.Stream
import java.util.stream.StreamSupport

/**
 * SequenceCore は Java Stream を直接保持する最小限の遅延チェーンコンテナ。
 */
data SequenceCore<T>(stream: Stream<T>)

/**
 * SequenceCore を生成するためのトップレベルファクトリ。
 *
 * stdlib 内部で Iterable/Stream から遅延チェーンを開始する用途に限定し、
 * Zero runtime 原則に従って JDK Stream 以外の補助ランタイムを導入しないことを明記する。
 */
object SequenceFactory {
    /**
     * Iterable から遅延チェーンを開始する内部用エントリポイント。
     * Zero runtime ポリシーに従い、JDK 標準 API だけで SequenceCore を構築する。
     */
    fun <T> fromIterable(source: Iterable<T>): SequenceCore<T> {
        return SequenceCore(StreamSupport.stream(source.spliterator(), false))
    }

    /**
     * 既存の Stream を追加オブジェクトなしで SequenceCore に包む内部用ヘルパー。
     * Zero runtime 原則により、保持するのは受け取った Stream のみとする。
     */
    fun <T> fromStream(stream: Stream<T>): SequenceCore<T> {
        return SequenceCore(stream)
    }
}

fun <T> SequenceCore<T>.iterator(): Iterator<T> {
    return this.stream.iterator()
}

fun <T> SequenceCore<T>.close() {
    this.stream.close()
}

fun <T> SequenceCore<T>.toStream(): Stream<T> {
    return this.stream
}

/**
 * Kotlin `Sequence.map` と同等の変換操作。
 */
fun <T, R> SequenceCore<T>.map(transform: (T) -> R): SequenceCore<R> {
    return SequenceFactory.fromStream(
        this.toStream().map { value -> transform(value) }
    )
}

/**
 * Kotlin `Sequence.filter` と同等のフィルタ操作。
 */
fun <T> SequenceCore<T>.filter(predicate: (T) -> Boolean): SequenceCore<T> {
    return SequenceFactory.fromStream(
        this.toStream().filter { value -> predicate(value) }
    )
}

/**
 * Kotlin `Sequence.take` と同等の範囲制御操作。
 */
fun <T> SequenceCore<T>.take(count: Int): SequenceCore<T> {
    return SequenceFactory.fromStream(
        this.toStream().limit(count.toLong())
    )
}

/**
 * Kotlin `Sequence.drop` と同等のスキップ操作。
 */
fun <T> SequenceCore<T>.drop(count: Int): SequenceCore<T> {
    return SequenceFactory.fromStream(
        this.toStream().skip(count.toLong())
    )
}

/**
 * Kotlin `Sequence.flatMap` と同等のフラット化操作。
 */
fun <T, R> SequenceCore<T>.flatMap(transform: (T) -> Iterable<R>): SequenceCore<R> {
    return SequenceFactory.fromStream(
        this.toStream().flatMap { value ->
            StreamSupport.stream(transform(value).spliterator(), false)
        }
    )
}

fun <T, R> SequenceCore<T>.flatMap(transform: (T) -> SequenceCore<R>): SequenceCore<R> {
    return SequenceFactory.fromStream(
        this.toStream().flatMap { value -> transform(value).toStream() }
    )
}

/**
 * Kotlin `Sequence.sorted` と同等のソート操作。
 */
fun <T : Comparable<T>> SequenceCore<T>.sorted(): SequenceCore<T> {
    return SequenceFactory.fromStream(this.toStream().sorted())
}

/**
 * Kotlin `Sequence.sortedBy` と同等のキー指定ソート。
 */
fun <T, R : Comparable<R>> SequenceCore<T>.sortedBy(selector: (T) -> R): SequenceCore<T> {
    return SequenceFactory.fromStream(
        this.toStream().sorted(
            Comparator.comparing { value -> selector(value) }
        )
    )
}

/**
 * Kotlin `Sequence.toList` と同等の終端操作。
 */
fun <T> SequenceCore<T>.toList(): List<T> {
    return this.toStream().toList()
}

/**
 * Kotlin `Sequence.fold` と同等の集約操作。
 */
fun <T, R> SequenceCore<T>.fold(initial: R, operation: (R, T) -> R): R {
    var accumulator = initial
    val iterator = this.toStream().iterator()
    while (iterator.hasNext()) {
        val value = iterator.next()
        accumulator = operation(accumulator, value)
    }
    return accumulator
}

/**
 * Kotlin `Sequence.reduce` と同等の集約操作。
 */
fun <T> SequenceCore<T>.reduce(operation: (T, T) -> T): T {
    val iterator = this.toStream().iterator()
    if (!iterator.hasNext()) {
        throw IllegalArgumentException("Sequence reduce() on empty source")
    }

    var accumulator = iterator.next()
    while (iterator.hasNext()) {
        val value = iterator.next()
        accumulator = operation(accumulator, value)
    }
    return accumulator
}

/**
 * Kotlin `Sequence.count` に対応する要素数集計。
 */
fun <T> SequenceCore<T>.count(): Long {
    return this.toStream().count()
}

/**
 * Kotlin `Sequence.sum` 相当の数値集計。
 */
fun <T> SequenceCore<T>.sum(): Long {
    var total: Long = 0
    val iterator = this.toStream().iterator()
    while (iterator.hasNext()) {
        val value = iterator.next() as Number
        total += value.longValue()
    }
    return total
}

/**
 * Kotlin `Sequence.forEach` と同等の副作用操作。
 */
fun <T> SequenceCore<T>.forEach(action: (T) -> Unit) {
    this.toStream().forEach { value -> action(value) }
}

/**
 * Kotlin `Sequence.groupBy` と同等のキー集約操作。
 */
fun <T, K> SequenceCore<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {
    val iterator = this.toStream().iterator()
    val result: LinkedHashMap<K, List<T>> = LinkedHashMap()
    while (iterator.hasNext()) {
        val element = iterator.next()
        val key = keySelector(element)

        var bucket = result.get(key)
        if (bucket == null) {
            bucket = ArrayList()
            result.put(key, bucket)
        }

        bucket.add(element)
    }
    return result
}

/**
 * Kotlin `Sequence.associate` と同等のキー／値マップ生成。
 */
fun <T, K, V> SequenceCore<T>.associate(transform: (T) -> Map.Entry<K, V>): Map<K, V> {
    val iterator = this.toStream().iterator()
    val result: LinkedHashMap<K, V> = LinkedHashMap()
    while (iterator.hasNext()) {
        val element = iterator.next()
        val entry = transform(element)
        result.put(entry.getKey(), entry.getValue())
    }
    return result
}

/**
 * コレクションから Kotlin `Sequence.map` 相当の遅延チェーンを開始する拡張。
 */
fun <T, R> Iterable<T>.map(transform: (T) -> R): SequenceCore<R> {
    return SequenceFactory.fromIterable(this).map(transform)
}

/**
 * コレクションから Kotlin `Sequence.filter` 相当の遅延チェーンを開始する拡張。
 */
fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): SequenceCore<T> {
    return SequenceFactory.fromIterable(this).filter(predicate)
}

/**
 * コレクションから Kotlin `Sequence.take` 相当の遅延チェーンを開始する拡張。
 */
fun <T> Iterable<T>.take(count: Int): SequenceCore<T> {
    return SequenceFactory.fromIterable(this).take(count)
}

/**
 * コレクションから Kotlin `Sequence.drop` 相当の遅延チェーンを開始する拡張。
 */
fun <T> Iterable<T>.drop(count: Int): SequenceCore<T> {
    return SequenceFactory.fromIterable(this).drop(count)
}

/**
 * コレクションから Kotlin `Sequence.flatMap` 相当の遅延チェーンを開始する拡張。
 */
fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): SequenceCore<R> {
    return SequenceFactory.fromIterable(this).flatMap(transform)
}

fun <T, R> Iterable<T>.flatMap(transform: (T) -> SequenceCore<R>): SequenceCore<R> {
    return SequenceFactory.fromIterable(this).flatMap(transform)
}

/**
 * Kotlin `Iterable.sorted` に準拠した遅延ソート開始。
 */
fun <T : Comparable<T>> Iterable<T>.sorted(): SequenceCore<T> {
    return SequenceFactory.fromIterable(this).sorted()
}

/**
 * Kotlin `Iterable.sortedBy` に準拠したキー指定ソートの遅延チェーン。
 */
fun <T, R : Comparable<R>> Iterable<T>.sortedBy(selector: (T) -> R): SequenceCore<T> {
    return SequenceFactory.fromIterable(this).sortedBy(selector)
}

/**
 * Kotlin `Iterable.fold` と同等の集約操作。
 */
fun <T, R> Iterable<T>.fold(initial: R, operation: (R, T) -> R): R {
    return SequenceFactory.fromIterable(this).fold(initial, operation)
}

/**
 * Kotlin `Iterable.reduce` と同等の集約操作。
 */
fun <T> Iterable<T>.reduce(operation: (T, T) -> T): T {
    return SequenceFactory.fromIterable(this).reduce(operation)
}

/**
 * Kotlin `Iterable.count` と同等の要素数集計。
 */
fun <T> Iterable<T>.count(): Long {
    return SequenceFactory.fromIterable(this).count()
}

/**
 * Kotlin `Iterable.sum` と同等の数値集計。
 */
fun <T> Iterable<T>.sum(): Long {
    return SequenceFactory.fromIterable(this).sum()
}

/**
 * Kotlin `Iterable.forEach` と同等の副作用操作。
 */
fun <T> Iterable<T>.forEach(action: (T) -> Unit) {
    SequenceFactory.fromIterable(this).forEach(action)
}

/**
 * Kotlin `Iterable.groupBy` と同等のマップ生成。
 */
fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {
    return SequenceFactory.fromIterable(this).groupBy(keySelector)
}

/**
 * Kotlin `Iterable.associate` と同等のキー／値マップ生成。
 */
fun <T, K, V> Iterable<T>.associate(transform: (T) -> Map.Entry<K, V>): Map<K, V> {
    return SequenceFactory.fromIterable(this).associate(transform)
}
