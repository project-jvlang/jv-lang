package jv.stdlib.collections.tests

import java.util.Map
import jv.collections.SequenceFactory

data Person(name: String age: Int)

fun validateSampleSingleStageOperations() {
    numbers = [1 2 3 4 5]

    doubled = numbers
        .map { value -> value * 2 }
        .toList()
    if (doubled != [2 4 6 8 10]) {
        throw IllegalStateException("map expected [2 4 6 8 10] but was ${doubled}")
    }

    evens = numbers
        .filter { value -> value % 2 == 0 }
        .toList()
    if (evens != [2 4 6 8]) {
        throw IllegalStateException("filter expected [2 4 6 8] but was ${evens}")
    }

    sum = numbers.reduce { left right -> left + right }
    if (sum != 15) {
        throw IllegalStateException("reduce expected 15 but was ${sum}")
    }
}

fun validatePhase1MapFilterToList() {
    numbers = [1 2 3 4 5]
    result = numbers
        .map { value -> value * 2 }
        .filter { candidate -> candidate >= 6 }
        .toList()

    expected = [6 8 10]
    if (result != expected) {
        throw IllegalStateException("map/filter/toList expected ${expected} but was ${result}")
    }
}

fun validatePhase1SequenceFromIterableToList() {
    numbers = [10 20 30]
    sequence = SequenceFactory.fromIterable(numbers)
    result = sequence
        .map { value -> value / 10 }
        .toList()

    expected = [1 2 3]
    if (result != expected) {
        throw IllegalStateException("SequenceFactory.fromIterable toList expected ${expected} but was ${result}")
    }
}

fun validatePhase1FilterOnlyChain() {
    numbers = [5 6 7 8 9]
    result = numbers
        .filter { value -> value % 2 == 0 }
        .toList()

    expected = [6 8]
    if (result != expected) {
        throw IllegalStateException("filter/toList expected ${expected} but was ${result}")
    }
}

fun validatePhase2TakeDropChain() {
    numbers = [1 2 3 4 5 6]
    result = numbers
        .map { value -> value * 10 }
        .drop(2)
        .take(3)
        .toList()

    expected = [30 40 50]
    if (result != expected) {
        throw IllegalStateException("drop/take chain expected ${expected} but was ${result}")
    }
}

fun validatePhase2FlatMapFromIterable() {
    groups = [
        [1 2]
        [3 4]
        [5]
    ]

    result = groups
        .flatMap { group -> group }
        .toList()

    expected = [1 2 3 4 5]
    if (result != expected) {
        throw IllegalStateException("flatMap from iterable expected ${expected} but was ${result}")
    }
}

fun validatePhase2FlatMapFromSequence() {
    base = SequenceFactory.fromIterable([1 2 3])
    result = base
        .flatMap { value -> [value value * 10] }
        .take(4)
        .toList()

    expected = [1 10 2 20]
    if (result != expected) {
        throw IllegalStateException("flatMap sequence expected ${expected} but was ${result}")
    }
}

fun validatePhase3FoldAggregates() {
    numbers = [1 2 3 4]
    total = numbers
        .map { value -> value * 2 }
        .fold(10) { acc value -> acc + value }

    if (total != 30) {
        throw IllegalStateException("fold expected 30 but was ${total}")
    }
}

fun validatePhase3ReduceAggregates() {
    numbers = SequenceFactory.fromIterable([5 6 7])
    reduceResult = numbers.reduce { left right -> left + right }

    if (reduceResult != 18) {
        throw IllegalStateException("reduce expected 18 but was ${reduceResult}")
    }
}

fun validatePhase3ReduceEmptyThrows() {
    emptySequence = SequenceFactory.fromIterable([])

    try {
        emptySequence.reduce { left right -> left + right }
        throw IllegalStateException("reduce on empty sequence should throw IllegalArgumentException")
    } catch (error: IllegalArgumentException) {
        // expected
    }
}

fun validatePhase3CountAndSum() {
    numbers = [2 4 6 8]
    countResult = numbers.count()
    if (countResult != 4L) {
        throw IllegalStateException("count expected 4 but was ${countResult}")
    }

    sumResult = numbers
        .map { value -> value + 1 }
        .sum()

    if (sumResult != 30L) {
        throw IllegalStateException("sum expected 30 but was ${sumResult}")
    }
}

fun validatePhase4SortedSequence() {
    numbers = [5 2 4 1 3]
    result = numbers
        .sorted()
        .toList()

    expected = [1 2 3 4 5]
    if (result != expected) {
        throw IllegalStateException("sorted expected ${expected} but was ${result}")
    }
}

fun validatePhase4SortedBySequence() {
    people = [
        Person("Carol" 40)
        Person("Alice" 32)
        Person("Bob" 28)
    ]

    result = people
        .sortedBy { person -> person.age }
        .toList()

    expected = [
        Person("Bob" 28)
        Person("Alice" 32)
        Person("Carol" 40)
    ]

    if (result != expected) {
        throw IllegalStateException("sortedBy expected ${expected} but was ${result}")
    }
}

fun validatePhase4GroupByOperation() {
    words = ["alpha" "amber" "bravo" "blue"]
    grouped = words.groupBy { word -> word.substring(0 1) }

    if (grouped.size() != 2) {
        throw IllegalStateException("groupBy expected 2 buckets but was ${grouped.size()}")
    }

    aBucket = grouped.get("a")
    if (aBucket == null || aBucket != ["alpha" "amber"]) {
        throw IllegalStateException("groupBy bucket 'a' expected [alpha amber] but was ${aBucket}")
    }

    bBucket = grouped.get("b")
    if (bBucket == null || bBucket != ["bravo" "blue"]) {
        throw IllegalStateException("groupBy bucket 'b' expected [bravo blue] but was ${bBucket}")
    }
}

fun validatePhase4AssociateOperation() {
    entries = [
        Person("Alice" 32)
        Person("Bob" 28)
        Person("Bob" 35)
    ]

    associated = entries.associate { person -> Map.entry(person.name person.age) }

    if (associated.size() != 2) {
        throw IllegalStateException("associate expected size 2 but was ${associated.size()}")
    }

    if (associated.get("Alice") != 32) {
        throw IllegalStateException("associate expected Alice -> 32 but was ${associated.get("Alice")}")
    }

    if (associated.get("Bob") != 35) {
        throw IllegalStateException("associate expected Bob -> 35 but was ${associated.get("Bob")}")
    }
}

fun validatePhase5ForEachSideEffects() {
    numbers = [1 2 3 4]
    var total = 0

    numbers
        .map { value -> value * 3 }
        .forEach { value -> total = total + value }

    if (total != 30) {
        throw IllegalStateException("forEach expected total 30 but was ${total}")
    }
}
