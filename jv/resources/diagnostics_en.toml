[generic.conflicting_argument]
message = "Multiple candidates were inferred for type parameter T{type_param} of {symbol}: existing {previous} conflicts with new {candidate}. Add an explicit annotation to disambiguate."
note_existing = "The previous assignment was recorded at {existing_span}."
note_explain = "Run --explain JV2001 to inspect the constraint breakdown."

[generic.bound_violation]
message = "Type parameter T{type_param} of {symbol} must satisfy {predicate}, but the inferred type does not."
note_hint = "Implement the required interface/trait or adjust the type argument."
note_explain = "Run --explain JV2002 to learn how to resolve missing bounds."

[generic.unresolved_parameter]
message = "Unable to resolve type parameter T{type_param} of {symbol}. {requirement}"
note_hint = "Add explicit type arguments or bounds to guide the inference engine."
note_explain = "Run --explain JV2001 for a step-by-step guide."

[generic.capability_not_found]
message = "No implementation of capability {capability} was found for type parameter T{type_param} of {symbol}."
note_hint = "Add impl {capability}<{target}> { ... } or verify that the dependency providing it is available."
note_preferred = "Preferred implementation {preferred_impl} was not found either."

[generic.capability_ambiguous]
message = "Capability {capability} for type parameter T{type_param} of {symbol} is ambiguous: {candidates}."
note_hint = "Set preferredImpl or add an explicit annotation to select the desired implementation."

[generic.kind_mismatch]
message = "Type parameter {type_param} of {symbol} expects kind {expected}, but the argument has kind {actual}."
note_span = "The type argument originates at {span}."
note_hint = "Adjust the kind annotation or supply the missing type constructors."

[imports.diagnostic.unknown]
message = "Import `{path}` could not be resolved."
message_with_candidates = "Import `{path}` could not be resolved. Close matches:\n{candidates}"
suggestion = "Use `import {candidate}`"

[imports.diagnostic.ambiguous]
message = "Import `{path}` matches multiple symbols."
message_with_candidates = "Import `{path}` matches multiple symbols. Pick an explicit target:\n{candidates}"
suggestion = "Use `import {candidate}` or `import {candidate} as ...`"
generic_suggestion = "Provide an `as` alias to disambiguate the import"

[imports.diagnostic.missing_module]
message = "Module `{module}` is missing from the module graph, preventing `{required_by}` from resolving."
suggestion = "Add `--add-modules {module}` or list it under build.modules in jv.toml."

[imports.plan]
header = "Resolved import list"
header_none = "No resolved imports found"

[imports.plan.type]
summary = "Type import: {fqcn}"

[imports.plan.package]
summary = "Package import: {name}.*"

[imports.plan.static]
summary = "Static import: {owner}.{member}"

[imports.plan.module]
summary = "Module import: {name}"

[imports.plan.alias]
summary = "Alias: {alias}"

[imports.plan.module_dependency]
summary = "Module dependency: {module}"

[raw_string.unterminated]
message = "JV4300: Raw string literal is unterminated. Add the matching closing quote sequence (' or ''')."
note_hint = "For triple-quoted raw strings, close the literal with the same ''' sequence used at the start."

[raw_string.ambiguous_char]
message = "JV4301: Single-character literal is ambiguous. Clarify whether it should be treated as Char or String."
note_hint = "Use \"a\" or toString() when you need a String, or annotate the binding as Char when a character value is intended."
