name: manual-release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g. v0.5.0)'
        required: true
        type: string
      release-notes:
        description: 'Additional release notes (optional)'
        required: false
        type: string

permissions:
  contents: write

jobs:
  build:
    name: Build ${{ matrix.artifact_suffix }} binaries
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            artifact_suffix: linux-x86_64
            binary_ext: ""
            target: x86_64-unknown-linux-gnu
          - os: macos-13
            artifact_suffix: macos-x86_64
            binary_ext: ""
            target: x86_64-apple-darwin
          # TODO: Enable macOS ARM64 build after fixing ring dependency issue
          # ring v0.17.14 has compile errors on aarch64-apple-darwin
          # Error: evaluation panicked: assertion failed in cpu/aarch64/darwin.rs
          # Possible solutions:
          #   1. Wait for ring v0.17.15+ release with Apple Silicon fix
          #   2. Use rustls-native-certs instead of ring
          #   3. Switch to native-tls backend
          # - os: macos-latest
          #   artifact_suffix: macos-aarch64
          #   binary_ext: ""
          #   target: aarch64-apple-darwin
          - os: windows-latest
            artifact_suffix: windows-x86_64
            binary_ext: ".exe"
            target: x86_64-pc-windows-msvc
          - os: ubuntu-latest
            artifact_suffix: linux-aarch64
            binary_ext: ""
            target: aarch64-unknown-linux-gnu
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: jv -> target

      - name: Install aarch64 linker
        if: matrix.target == 'aarch64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu

      - name: Add Rust target
        run: rustup target add ${{ matrix.target }}

      - name: Configure aarch64 linker
        if: matrix.target == 'aarch64-unknown-linux-gnu'
        run: |
          mkdir -p .cargo
          cat >> .cargo/config.toml << EOF
          [target.aarch64-unknown-linux-gnu]
          linker = "aarch64-linux-gnu-gcc"
          EOF

      - name: Build release binaries
        run: cargo build --release -p jv_cli --target ${{ matrix.target }}
        working-directory: jv

      - name: Upload binaries
        uses: actions/upload-artifact@v4
        with:
          name: binaries-${{ matrix.artifact_suffix }}
          path: |
            jv/target/${{ matrix.target }}/release/jv${{ matrix.binary_ext }}
            jv/target/${{ matrix.target }}/release/jvx${{ matrix.binary_ext }}

  release:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: downloads

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Package release archives
        run: |
          set -euo pipefail
          VERSION="${{ inputs.version }}"
          RELEASE_DIR="release"
          mkdir -p "$RELEASE_DIR"

          # Find binaries inside the downloaded artifact folder (handles nested paths)
          find_binary() {
            # $1: base dir, $2: filename
            find "$1" -type f -name "$2" | head -n1
          }

          package_tarball() {
            # $1: src_dir, $2: suffix
            local src_dir="$1"; local suffix="$2"
            if [ -d "$src_dir" ]; then
              local jv_path; jv_path="$(find_binary "$src_dir" jv || true)"
              local jvx_path; jvx_path="$(find_binary "$src_dir" jvx || true)"
              if [ -n "${jv_path}" ] && [ -n "${jvx_path}" ]; then
                local tmp_dir; tmp_dir="$(mktemp -d)"
                cp "${jv_path}" "${tmp_dir}/jv"
                cp "${jvx_path}" "${tmp_dir}/jvx"
                tar -czf "${RELEASE_DIR}/jv-${VERSION}-${suffix}.tar.gz" -C "${tmp_dir}" jv jvx
                sha256sum "${RELEASE_DIR}/jv-${VERSION}-${suffix}.tar.gz" > "${RELEASE_DIR}/jv-${VERSION}-${suffix}.tar.gz.sha256"
                rm -rf "${tmp_dir}"
              else
                echo "[package] Skipping ${suffix}: binaries not found under ${src_dir}" >&2
              fi
            else
              echo "[package] Skipping ${suffix}: directory not found: ${src_dir}" >&2
            fi
          }

          package_tarball "downloads/binaries-linux-x86_64" "linux-x86_64"
          package_tarball "downloads/binaries-macos-x86_64" "macos-x86_64"
          # TODO: Re-enable after fixing ring dependency for Apple Silicon
          # package_tarball "downloads/binaries-macos-aarch64" "macos-aarch64"
          package_tarball "downloads/binaries-linux-aarch64" "linux-aarch64"

          WINDOWS_DIR="downloads/binaries-windows-x86_64"
          if [ -d "$WINDOWS_DIR" ]; then
            jv_win="$(find_binary "$WINDOWS_DIR" 'jv.exe' || true)"
            jvx_win="$(find_binary "$WINDOWS_DIR" 'jvx.exe' || true)"
            if [ -n "${jv_win}" ] && [ -n "${jvx_win}" ]; then
              zip -j "${RELEASE_DIR}/jv-${VERSION}-windows-x86_64.zip" "${jv_win}" "${jvx_win}"
              sha256sum "${RELEASE_DIR}/jv-${VERSION}-windows-x86_64.zip" > "${RELEASE_DIR}/jv-${VERSION}-windows-x86_64.zip.sha256"
            else
              echo "[package] Skipping windows-x86_64: executables not found under ${WINDOWS_DIR}" >&2
            fi
          else
            echo "[package] Skipping windows-x86_64: directory not found: ${WINDOWS_DIR}" >&2
          fi

          cp scripts/install_toolchain_jdks.sh "${RELEASE_DIR}/install_toolchain_jdks.sh"
          chmod +x "${RELEASE_DIR}/install_toolchain_jdks.sh"

      - name: Generate install script
        run: |
          set -euo pipefail
          VERSION="${{ inputs.version }}"
          REPO="${{ github.repository }}"
          RELEASE_DIR="release"
          INSTALL_SCRIPT="${RELEASE_DIR}/install.sh"

          cat > "${INSTALL_SCRIPT}" << 'INSTALL_EOF'
          #!/usr/bin/env bash
          set -euo pipefail

          VERSION="VERSION_PLACEHOLDER"
          REPO="REPO_PLACEHOLDER"

          die() {
            echo "install.sh: $*" >&2
            exit 1
          }

          log() {
            echo "[install] $*" >&2
          }

          require_cmd() {
            command -v "$1" >/dev/null 2>&1 || die "Required command '$1' not found in PATH"
          }

          require_cmd uname
          require_cmd curl
          require_cmd tar
          require_cmd install

          OS="$(uname -s)"
          ARCH="$(uname -m)"
          SUFFIX="${JV_INSTALL_SUFFIX:-}"

          if [[ -z "$SUFFIX" ]]; then
            case "$OS" in
              Linux*)
                case "$ARCH" in
                  x86_64|amd64) SUFFIX="linux-x86_64" ;;
                  aarch64|arm64) SUFFIX="linux-aarch64" ;;
                  *) die "Unsupported Linux architecture: $ARCH" ;;
                esac
                ;;
              Darwin*)
                case "$ARCH" in
                  x86_64) SUFFIX="macos-x86_64" ;;
                  arm64|aarch64)
                    die "macOS ARM64 (Apple Silicon) is not yet supported due to dependency issues. Please use Rosetta to run the x86_64 version: arch -x86_64 /bin/bash -c \"\$(curl -fsSL https://github.com/${REPO}/releases/latest/download/install.sh)\""
                    ;;
                  *)
                    die "Unsupported macOS architecture: $ARCH"
                    ;;
                esac
                ;;
              *)
                die "Unsupported operating system: $OS"
                ;;
            esac
          fi

          ARCHIVE_BASENAME="jv-${VERSION}-${SUFFIX}"
          case "$SUFFIX" in
            windows-*) die "Windows installation is not supported by this script. Please download the ZIP manually." ;;
            *) ARCHIVE_NAME="${ARCHIVE_BASENAME}.tar.gz" ;;
          esac

          DOWNLOAD_URL="https://github.com/${REPO}/releases/download/${VERSION}/${ARCHIVE_NAME}"
          JDK_SCRIPT_URL="https://github.com/${REPO}/releases/download/${VERSION}/install_toolchain_jdks.sh"

          TMP_DIR="$(mktemp -d)"
          trap 'rm -rf "$TMP_DIR"' EXIT

          ARCHIVE_PATH="${TMP_DIR}/${ARCHIVE_NAME}"
          log "Downloading ${ARCHIVE_NAME}..."
          curl -L "${DOWNLOAD_URL}" -o "${ARCHIVE_PATH}"

          log "Extracting archive..."
          tar -xzf "${ARCHIVE_PATH}" -C "${TMP_DIR}"
          [[ -f "${TMP_DIR}/jv" && -f "${TMP_DIR}/jvx" ]] || die "Archive did not contain jv binaries"

          BIN_DIR="${JV_BIN_DIR:-$HOME/.local/bin}"
          mkdir -p "${BIN_DIR}"
          install -m 0755 "${TMP_DIR}/jv" "${BIN_DIR}/jv"
          install -m 0755 "${TMP_DIR}/jvx" "${BIN_DIR}/jvx"
          log "Installed jv and jvx to ${BIN_DIR}"

          if ! command -v jv >/dev/null 2>&1; then
            log "Warning: ${BIN_DIR} is not on your PATH. Add the following to your shell profile:"
            log "  export PATH=\"${BIN_DIR}:\$PATH\""
          fi

          INSTALL_ROOT="${JV_INSTALL_ROOT:-$HOME/.jv}"
          SCRIPT_DIR="${INSTALL_ROOT}/scripts"
          mkdir -p "${SCRIPT_DIR}"

          log "Downloading JDK setup helper..."
          curl -L "${JDK_SCRIPT_URL}" -o "${SCRIPT_DIR}/install_toolchain_jdks.sh"
          chmod +x "${SCRIPT_DIR}/install_toolchain_jdks.sh"

          log "Ensuring GraalVM toolchains..."
          "${SCRIPT_DIR}/install_toolchain_jdks.sh" "${INSTALL_ROOT}"

          log "Installation complete."
          INSTALL_EOF

          sed -i "s|VERSION_PLACEHOLDER|${VERSION}|g" "${INSTALL_SCRIPT}"
          sed -i "s|REPO_PLACEHOLDER|${REPO}|g" "${INSTALL_SCRIPT}"
          chmod +x "${INSTALL_SCRIPT}"

      - name: Prepare release body
        id: release_body
        run: |
          if [ -z "${{ inputs.release-notes }}" ]; then
            echo "body=Automated release for version ${{ inputs.version }}" >> "$GITHUB_OUTPUT"
          else
            echo "body=${{ inputs.release-notes }}" >> "$GITHUB_OUTPUT"
          fi

      - name: Publish GitHub release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ inputs.version }}
          name: jv ${{ inputs.version }}
          body: ${{ steps.release_body.outputs.body }}
          makeLatest: true
          prerelease: false
          draft: false
          allowUpdates: true
          # Upload everything produced in the release directory
          artifacts: "release/*"
          artifactErrorsFailBuild: true
